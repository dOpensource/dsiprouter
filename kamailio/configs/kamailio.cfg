#!KAMAILIO

#======================================================================
# Defined Features Enabled
#======================================================================

#!define WITH_MYSQL
#!define WITH_AUTH
#!define WITH_IPAUTH
#!define WITH_UAC
#!define WITH_USRLOCDB
#!define WITH_ACCDB
#!define WITH_CDRS
#!define WITH_DROUTE
##!define WITH_DEBUG
#!define WITH_NAT
#!define WITH_DISPATCHER
#!define WITH_CALL_SETTINGS
##!define WITH_SIGNAL_SERVERNAT
##!define WITH_SIGNAL_SERVERNAT6
##!define WITH_MEDIA_SERVERNAT
#!define WITH_MULTIDOMAIN
#!define WITH_TELEBLOCK
#!define WITH_ANTIFLOOD
##!define WITH_DBCLUSTER
#!define WITH_LCR
#!define WITH_TLS
#!define WITH_SCTP
#!define WITH_WEBSOCKETS
##!define WITH_DMQ
#!define WITH_MSTEAMS
##!define WITH_DNID_LNP_ENRICHMENT
#!define WITH_RTPENGINE
#!define WITH_TRANSNEXUS
#!define WITH_STIRSHAKEN
##!define WITH_IPV6
##!define WITH_HOMER
##!define WITH_DMZ
##!define WITH_PUSH

#======================================================================
# Define String Replacements Within Config
#======================================================================

#!subst "!DMQ_REPLICATE_ENABLED!0!g"

#======================================================================
# Defined Constants with String Replacement
#======================================================================

#!substdef "!DSIP_ID!!g"
#!substdef "!DSIP_CLUSTER_ID!!g"
#!substdef "!DSIP_VERSION!!g"
#!substdef "!HOMER_ID!!g"
#!substdef "!INTERNAL_IP_ADDR!!g"
#!substdef "!INTERNAL_IP_NET!!g"
#!substdef "!INTERNAL_IP6_ADDR!!g"
#!substdef "!INTERNAL_IP6_NET!!g"
#!substdef "!INTERNAL_FQDN!!g"
#!substdef "!EXTERNAL_IP_ADDR!!g"
#!substdef "!EXTERNAL_IP6_ADDR!!g"
#!substdef "!EXTERNAL_FQDN!!g"
#!substdef "!UAC_REG_ADDR!!g"
#!substdef "!INBOUND_NLB_FQDN!!g"
#!substdef "!OUTBOUND_NLB_FQDN!!g"
#!substdef "!HOMER_HOST!!g"
#!substdef "!SIP_PORT!5060!g"
#!substdef "!SIPS_PORT!5061!g"
#!substdef "!DMQ_PORT!5090!g"
#!substdef "!WSS_PORT!4443!g"
#!substdef "!HEP_PORT!9060!g"
#!substdef "!RTPENGINE_URI!udp:127.0.0.1:7722!g"

#======================================================================
# Defined Constants
#======================================================================

# - database URL - used to connect to database server by modules
#!ifdef WITH_MYSQL
#!ifdef WITH_DBCLUSTER
#!define DBURL "cluster://dbcluster"
#!define SQLCONN_KAM "kam=>mysql://kamailio:kamailiorw@localhost:3306/kamailio"
#!define SQLCONN_AST "asterisk=>mysql://kamailio:kamailiorw@localhost:3306/kamailio"
#!else
#!define DBURL "mysql://kamailio:kamailiorw@localhost:3306/kamailio"
#!define SQLCONN_KAM "kam=>mysql://kamailio:kamailiorw@localhost:3306/kamailio"
#!define SQLCONN_AST "asterisk=>mysql://kamailio:kamailiorw@localhost:3306/kamailio"
#!endif
#!endif

### constants used by dispatcher routes
#!define DSTALG_ROUND_ROBIN 4
#!define DSTALG_PRIORITY_BASED 8
#!define DSTALG_WEIGHT_BASED 9
#!define DSTALG_LOAD_DISTRIBUTION 10
#!define DSTALG_RELATIVE_WEIGHT 11
#!define DSTALG_PARALLEL_FORKING 12

#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif


### flag definitions and usage:
# NOTE: flags are stored in each bit of an integer, there range is from 0-31 (32 bits)
# NOTE: it seems each set/type of flags has their own variable / namespace
# FLT_ 		per transaction flags
#   usage:	setflag(), resetflag(), isflagset()
# FLB_ 		per branch flags
#   usage:	setbflag(), resetbflag(), isbflagset()
# FLS_ 		per script flags
#   usage:	setsflag(), resetsflag(), issflagset()
# FLD_ 		per dialog flags
#	usage:	dlg_setflag(), dlg_resetflag(), dlg_isflagset()
#!define FLT_ACC 0
#!define FLT_ACCMISSED 1
#!define FLT_ACCFAILED 2
#!define FLT_FAILOVER 3
#!define FLT_DLG_ALLOWED 4
#!define FLT_DOMAINROUTING 6
#!define FLT_PBX_AUTH 7
#!define FLT_CARRIER 8
#!define FLT_PBX 9
#!define FLT_CARRIER_AUTH 10
#!define FLT_EXTERNAL_AUTH 11
#!define FLT_PASSTHRU_AUTH 12
#!define FLT_SRC_SIP 13
#!define FLT_SRC_WS 14
#!define FLT_SRC_ALLOWED 15
#!define FLT_DST_INTERNAL_IP 16
#!define FLT_MSTEAMS 17
#!define FLT_SRC_INTERNAL_IP 18
#!define FLT_DST_IPV4 19
#!define FLT_DST_IPV6 20
#!define FLT_SRC_IPV4 21
#!define FLT_SRC_IPV6 22
#!define FLT_HAS_TOTAG 23
#!define FLB_NATB 0
#!define FLB_NATSIPPING 1
#!define FLB_WS_DEVICE 2
#!define FLB_SRC_PBX 3
#!define FLB_DST_PBX 4
#!define FLB_SRC_CARRIER 5
#!define FLB_DST_CARRIER 6
#!define FLB_SRC_MSTEAMS 7
#!define FLB_DST_MSTEAMS 8
#!define FLB_SRC_MSTEAMS_ONHOLD 9
#!define FLB_SRC_SELF 10
#!define FLD_USE_RTPE 1

# NOTE: not actual flags
#!define FLT_OUTBOUND 8000
#!define FLT_INBOUND 9000

#!define NOTIFICATION_OVERLIMIT "0"
#!define NOTIFICATION_GWFAILURE "1"

#======================================================================
# Global Parameters
#======================================================================

### LOG Levels:
# L_ALERT     -5
# L_BUG       -4
# L_CRIT2     -3
# L_CRIT      -2
# L_ERR       -1
# L_WARN       0
# L_NOTICE     1
# L_INFO       2
# L_DBG        3
#!ifdef WITH_DEBUG
debug = 3
log_stderror = false
#!else
debug = 2
log_stderror = false
#!endif

# specifies on which log level the memory debugger/statistics will be logged
memdbg = 5
memlog = 5

# syslog log facility messages will be logged to
log_facility = LOG_LOCAL0

# configure the prefix for all log messages
log_prefix_mode = 1
log_prefix = "[$cfg(name):$cfg(line):$cfg(route)] [$ci:$rm:$rs] "

# multiprocess settings on startup
fork = true
children = 1

# increase loop limit to allow 10000 DID checks for inbound calls
max_while_loops = 10000

# uncomment the next line to disable TCP (default on)
#disable_tcp = true

# uncomment the next line to disable the auto discovery of local aliases
# based on reverse DNS on IPs (default on)
#auto_aliases = false

# add local domain aliases
# NOTE:	port is required in alias for loose routing to function properly
# REF:	https://www.kamailio.org/wiki/cookbooks/5.5.x/core#alias
alias = "EXTERNAL_FQDN:SIP_PORT"
alias = "EXTERNAL_FQDN:SIPS_PORT"
alias = "EXTERNAL_FQDN:DMQ_PORT"
alias = "EXTERNAL_FQDN:WSS_PORT"
alias = "INBOUND_NLB_FQDN:SIP_PORT"
alias = "INBOUND_NLB_FQDN:SIPS_PORT"
alias = "INBOUND_NLB_FQDN:DMQ_PORT"
alias = "INBOUND_NLB_FQDN:WSS_PORT"
alias = "OUTBOUND_NLB_FQDN:SIP_PORT"
alias = "OUTBOUND_NLB_FQDN:SIPS_PORT"
alias = "OUTBOUND_NLB_FQDN:DMQ_PORT"
alias = "OUTBOUND_NLB_FQDN:WSS_PORT"

# configure interface/port/proto kamailio will bind on
listen = udp:127.0.0.1:SIP_PORT
listen = tcp:127.0.0.1:SIP_PORT
#!ifdef WITH_TLS
listen = tls:127.0.0.1:SIPS_PORT
#!ifdef WITH_WEBSOCKETS
listen = tls:127.0.0.1:WSS_PORT
#!endif
#!endif
#!ifdef WITH_SCTP
listen = sctp:127.0.0.1:SIP_PORT
#!endif

#!ifdef WITH_DMZ
listen = udp:EXTERNAL_IP_ADDR:SIP_PORT
listen = tcp:EXTERNAL_IP_ADDR:SIP_PORT
#!endif

#!ifdef WITH_SIGNAL_SERVERNAT
listen = udp:INTERNAL_IP_ADDR:SIP_PORT advertise EXTERNAL_IP_ADDR:SIP_PORT
listen = tcp:INTERNAL_IP_ADDR:SIP_PORT advertise EXTERNAL_IP_ADDR:SIP_PORT
#!ifdef WITH_TLS
#!ifdef WITH_WEBSOCKETS
listen = tls:INTERNAL_IP_ADDR:WSS_PORT advertise "EXTERNAL_FQDN":WSS_PORT
#!endif
#!endif
#!ifdef WITH_SCTP
listen = sctp:INTERNAL_IP_ADDR:SIP_PORT advertise EXTERNAL_IP_ADDR:SIP_PORT
#!endif
#!else
listen = udp:INTERNAL_IP_ADDR:SIP_PORT
listen = tcp:INTERNAL_IP_ADDR:SIP_PORT
#!ifdef WITH_TLS
#!ifdef WITH_WEBSOCKETS
listen = tls:INTERNAL_IP_ADDR:WSS_PORT
#!endif
#!endif
#!ifdef WITH_SCTP
listen = sctp:INTERNAL_IP_ADDR:SIP_PORT
#!endif
#!endif

#!ifdef WITH_IPV6
listen = udp:[::1]:SIP_PORT
listen = tcp:[::1]:SIP_PORT
#!ifdef WITH_TLS
listen = tls:[::1]:SIPS_PORT
#!ifdef WITH_WEBSOCKETS
listen = tls:[::1]:WSS_PORT
#!endif
#!endif
#!ifdef WITH_SCTP
listen = sctp:[::1]:SIP_PORT
#!endif
#!ifdef WITH_DMZ
listen = udp:[EXTERNAL_IP6_ADDR]:SIP_PORT
listen = tcp:[EXTERNAL_IP6_ADDR]:SIP_PORT
#!endif
#!ifdef WITH_SIGNAL_SERVERNAT6
listen = udp:[INTERNAL_IP6_ADDR]:SIP_PORT advertise EXTERNAL_IP6_ADDR:SIP_PORT
listen = tcp:[INTERNAL_IP6_ADDR]:SIP_PORT advertise EXTERNAL_IP6_ADDR:SIP_PORT
#!ifdef WITH_TLS
#!ifdef WITH_WEBSOCKETS
listen = tls:[INTERNAL_IP6_ADDR]:WSS_PORT advertise "EXTERNAL_FQDN":WSS_PORT
#!endif
#!endif
#!ifdef WITH_SCTP
listen = sctp:[INTERNAL_IP6_ADDR]:SIP_PORT advertise EXTERNAL_IP6_ADDR:SIP_PORT
#!endif
#!else
listen = udp:[INTERNAL_IP6_ADDR]:SIP_PORT
listen = tcp:[INTERNAL_IP6_ADDR]:SIP_PORT
#!endif
#!ifdef WITH_TLS
#!ifdef WITH_WEBSOCKETS
listen = tls:[INTERNAL_IP6_ADDR]:WSS_PORT
#!endif
#!endif
#!ifdef WITH_SCTP
listen = sctp:[INTERNAL_IP6_ADDR]:SIP_PORT
#!endif
#!endif

#!ifdef WITH_DMQ
listen = udp:INTERNAL_IP_ADDR:DMQ_PORT
#!endif

#!ifdef WITH_TLS
enable_tls = true
tcp_accept_no_cl = true
tcp_rd_buf_size = 16384
listen = tls:INTERNAL_IP_ADDR:SIPS_PORT advertise "EXTERNAL_FQDN":SIPS_PORT
#!ifdef WITH_IPV6
listen = tls:[INTERNAL_IP6_ADDR]:SIPS_PORT advertise "EXTERNAL_FQDN":SIPS_PORT
#!endif
#!endif

# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime = 3605

# Whether the “Server” header for locally generated messages is set
server_signature = true
# What the generated "Server" header will be set to
server_header = "Server: dSIPRouter/DSIP_VERSION"

# disable Stream Control Tranmission Protocol (SCTP)
#!ifdef WITH_SCTP
enable_sctp = 1
#!else
enable_sctp = 0
#!endif

# enable/disable DMZ support
#!ifdef WITH_DMZ
mhomed=1
#!else
mhomed=0
#!endif

####### Custom Parameters #########

# These parameters can be modified runtime via RPC interface
# - see the documentation of 'cfg_rpc' module.
#
# Format: group.id = value 'desc' description
# Access: $sel(cfg_get.group.id) or @cfg_get.group.id
#

#!ifdef WITH_VOICEMAIL
# VoiceMail Routing on offline, busy or no answer
#
# - by default Voicemail server IP is empty to avoid misrouting
voicemail.srv_ip = "" desc "VoiceMail IP Address"
voicemail.srv_port = "5060" desc "VoiceMail Port"
#!endif

#!ifdef WITH_TELEBLOCK
teleblock.gw_enabled = 0 desc "Enable Teleblock support"
teleblock.gw_ip = "62.34.24.22" desc "Teleblock IP"
teleblock.gw_port = "5066" desc "Teleblock Port"
teleblock.media_ip = "" desc "Teleblock media ip"
teleblock.media_port = "" desc "Teleblock media port"
#!endif

# Define the role of the server
#   ""     		- default behavior
#   outbound    - outbound only (no domain routing)
#   inout       - inbound and outbound only (no domain routing)
server.role = "" desc "Role of the server in the topology"

# Local calling maximum digits for the initiating PBX - PBX sending the INVITE
server.pbx_max_local_digits = 5 desc "Maximum digits for local pbx extensions"

# PBX INVITE Timeout (msecs) to support having a Primary and Secondary PBX
server.pbx_invite_timeout = 5000 desc "The default PBX INVITE timeout"

# PBX INVITE Timeout (msecs) if a SIP 100/180/181/183 message is received
server.pbx_invite_timeout_aftertry = 16000 desc "PBX INVITE timeout value if a SIP 100 message is received"

# DSIPRouter API Server Settings
server.api_server = "https://127.0.0.1:5000" desc "URL to the DSIPRouter API Server"
server.api_token = "admin" desc "API Token for DSIPRouter API Server"

# Emergency Numbers
server.emergency_numbers = "^([2-9]11|112|999|000|988|933)$" desc "Emergency Numbers"

# Transnexus External STIR/SHAKEN Support
transnexus.authservice_lrn_enabled = 0 desc "Enable LRN for authservice"
transnexus.authservice_enabled = 0 desc "Enable auth service for all Trunks"
transnexus.authservice_host = "outbound.sip.clearip.com:5060" desc "Host to connect to for auth service"
transnexus.verifyservice_enabled = 0 desc "Enable verify service for all Trunks"
transnexus.verifyservice_host = "inbound.sip.clearip.com:5060" desc "Host to connect to for verify service"

# Native Kamailio STIR/SHAKEN Support
stir_shaken.stir_shaken_enabled = 0 desc "Whether native STIR/SHAKEN support is enabled"
stir_shaken.stir_shaken_prefix_a = "" desc "Default Empty"
stir_shaken.stir_shaken_prefix_b = "" desc "Default Empty"
stir_shaken.stir_shaken_prefix_c = "" desc "Default Empty"
stir_shaken.stir_shaken_prefix_invalid = "" desc "Default Empty"
stir_shaken.stir_shaken_block_invalid = 0 desc "Default Disabled"
stir_shaken.stir_shaken_key_path = "/etc/dsiprouter/certs/stirshaken/stirshaken-key.pem" desc "Local path to RSA key"
stir_shaken.stir_shaken_cert_url = " https://cr.example.com/xK/order/xk" desc "URL to download X509 certificate from"

# MSTeams Settings
server.msteams_disable_refer = 1

# set location to load modules from (source or installation folders)
#!ifdef WITH_SRCPATH
mpath = "/usr/lib/x86_64-linux-gnu/kamailio/modules/"
#!else
mpath = "/usr/lib/x86_64-linux-gnu/kamailio/modules/"
#!endif

#======================================================================
# Module Loading
#======================================================================

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_SCTP
loadmodule "sctp.so"
#!endif

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "path.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "xhttp.so"
loadmodule "json.so"
loadmodule "jansson.so"
loadmodule "jsonrpcs.so"
loadmodule "http_async_client.so"
loadmodule "uuid.so"
loadmodule "ipops.so"
loadmodule "sdpops.so"
loadmodule "rtimer.so"
loadmodule "sqlops.so"

#!ifdef WITH_DEBUG
loadmodule "sipdump.so"
#!endif

#!ifdef WITH_DMQ
loadmodule "dmq.so"
loadmodule "dmq_usrloc.so"
#!endif
# must be loaded after dmq
loadmodule "htable.so"
loadmodule "dialog.so"

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!ifdef WITH_UAC
loadmodule "uac.so"
loadmodule "uac_redirect.so"
#!endif
#!endif

#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
#!endif

#!ifdef WITH_RTPENGINE
loadmodule "rtpengine.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

#!ifdef WITH_DROUTE
loadmodule "drouting.so"
#!endif

#!ifdef WITH_DBCLUSTER
loadmodule "db_cluster"
#!endif

#!ifdef WITH_DISPATCHER
loadmodule "keepalive.so"
loadmodule "dispatcher.so"
#!endif

#!ifdef WITH_WEBSOCKETS
loadmodule "websocket.so"
#!endif

#!ifdef WITH_STIRSHAKEN
loadmodule "stirshaken.so"
#!endif

#!ifdef WITH_HOMER
loadmodule "siptrace.so"
#!endif

#!ifdef WITH_PUSH
loadmodule "tsilo.so"
#!endif

#======================================================================
# Module-Specific Parameters
#======================================================================

# ---- xlog global params ----
modparam("xlog", "buf_size", 8192)
modparam("xlog", "prefix", "")

# ---- htable global params ----
modparam("htable", "db_url", DBURL)

# ---- dispatcher params ----
#!ifdef WITH_DISPATCHER
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "dispatcher")
# The flags column controls the mode of a destination and keepalives. It is a bitwise value that can be built using the following flags:
# 1	 (1 <<0):	inactive destination
# 2  (1 <<1):	temporary trying destination (in the way to become inactive if it does not reply to keepalives
# 4  (1 <<2):	admin disabled destination
# 8  (1 <<3):	probing destination (sending keep alives)
# 16 (1 <<4):	skip DNS A/AAAA resolve at startup, useful when the hostname of the destination address is a NAPTR or SRV record only
modparam("dispatcher", "flags_col", "flags")
# Controls what gateways are tested to see if they are reachable:
# 0:	Only the gateways with state PROBING (flags & 0x08 == 1) are tested. After a gateway is probed, the PROBING state is cleared in this mode (it will probe only one time at startup or after dispatcher reload).
# 1: 	All gateways are tested. If there is a failure of keepalive to an active gateway, then it is set to TRYING state.
# 2: 	Only gateways in INACTIVE state with PROBING mode set are tested.
# 3: 	Any gateway with state PROBING is continually probed without modifying/removing the PROBING state. This allows selected gateways to be probed continually, regardless of state changes.
modparam("dispatcher", "ds_probing_mode", 3)
modparam("dispatcher", "ds_ping_latency_stats", 1)		# 1 means to provide latency stats
modparam("dispatcher", "ds_ping_method", "OPTIONS")		# The SIP method to use when pinging destinations
modparam("dispatcher", "ds_ping_interval", 60)			# How often (seconds) to ping destinations to check status
modparam("dispatcher", "ds_probing_threshold", 1)		# How many failed ping requests before marking the destination as inactive
modparam("dispatcher", "ds_inactive_threshold", 1)		# How many successful ping requests before marking the destination as active
modparam("dispatcher", "xavp_dst", "dispatcher_dst")	# Will contain selected destination info
modparam("dispatcher", "xavp_dst_mode", 0)				# What attributes to set in the xavp
modparam("dispatcher", "xavp_ctx", "dispatcher_ctx")	# Will contain current dispatcher context info
modparam("dispatcher", "xavp_ctx_mode", 0)				# What attributes to set in the xavp
modparam("dispatcher", "reload_delta", 1)				# how quickly (in seconds) a RPC reload is allowed
#!endif

# ----- db_cluster params ----
# connection:   set for each db connection uri
# cluster:      s == serial, r == roundrobin, p == parallel (write/only)
#!ifdef WITH_DBCLUSTER
modparam("db_cluster", "connection", "c1=>mysql://kamailio:kamailiorw@192.168.1.2/kamailio")
modparam("db_cluster", "connection", "c2=>mysql://kamailio:kamailiorw@192.168.1.3/kamailio")
modparam("db_cluster", "connection", "c3=>mysql://kamailio:kamailiorw@192.168.1.4/kamailio")
modparam("db_cluster", "connection", "c4=>mysql://kamailio:kamailiorw@192.168.1.5/kamailio")
modparam("db_cluster", "cluster", "dbcluster=>c1=9r9r;c2=9r9r;c3=9r9r;c4=9r9r")
modparam("db_cluster", "inactive_interval", 180)
#!endif

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
modparam("jsonrpcs", "transport", 3)
#modparam#("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 60sec
modparam("tm", "fr_inv_timer", 60000)
# XAVP used to store contacts used by t_load_contacts()/t_next_contacts()
modparam("tm", "contacts_avp", "tm_contacts")
# Used to store contacts (if any) that it skipped, because they contained same +sip.instance
modparam("tm", "contact_flows_avp", "tm_contact_flows")
# consider branch failures for to_on_failure() routing as well
modparam("tm", "failure_exec_mode", 1)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# append from tag to the RR (required for is_direction() to work)
modparam("rr", "append_fromtag", 1)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)
# max value for expires of registrations
modparam("registrar", "max_expires", 0)
# set it to 1 to enable GRUU
modparam("registrar", "gruu_enabled", 0)

# ----- acc params -----
# what special events should be accounted?
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
# by default ww do not adjust the direction of the sequential requests
# if you enable this parameter, be sure the enable "append_fromtag" in "rr" module
modparam("acc", "detect_direction", 0)
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_facility", "LOG_LOCAL0")
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd;"
	"calltype=$avp(calltype);src_gwgroupid=$dlg_var(src_gwgroupid);dst_gwgroupid=$dlg_var(dst_gwgroupid)")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
# enhanced DB accounting
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd;"
	"calltype=$avp(calltype);src_gwgroupid=$dlg_var(src_gwgroupid);dst_gwgroupid=$dlg_var(dst_gwgroupid)")
#!endif

# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 3)
modparam("usrloc", "use_domain", MULTIDOMAIN)
modparam("usrloc", "handle_lost_tcp", 1)
#!endif

# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "password_column", "password")
# We use the rpid field of the subscriber table to track the assigned gwgroup (type of endpoint or carrier)
modparam("auth_db", "load_credentials", "$avp(s:src_gwgroupid)=rpid;")
modparam("auth_db", "use_domain", MULTIDOMAIN)

# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
# how quickly (in seconds) a RPC reload is allowed
modparam("permissions", "reload_delta", 1)
#!endif
#!endif

# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif

# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif

# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBURL)
# register callback to match myself condition with domains list
modparam("domain", "register_myself", 1)
#!endif

#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
#!endif

#!ifdef WITH_NAT
# ----- nathelper params -----
modparam("nathelper", "natping_interval", 60)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@UAC_REG_ADDR")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif

#!ifdef WITH_RTPENGINE
# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "RTPENGINE_URI")
# Specify if the RTPEngine instances have to be pinged at startup to detect if they are active. Set it to 0 to disable pinging and to 1 to activate pinging
modparam("rtpengine", "ping_mode", 0)
# Once an RTP proxy was found unreachable and marked as disabled, the rtpengine module will not attempt to establish communication to that RTP proxy for rtpengine_disable_tout seconds
modparam("rtpengine", "rtpengine_disable_tout", 0)
# How many times the module should retry to send and receive after timeout was generated
modparam("rtpengine", "rtpengine_retr", 5)
# Number of seconds after an rtpengine hash table entry is marked for deletion. The entries correspond to active calls using an rtpengine instance
# This should match the default rtpengine timeout set in rtpengine.conf
modparam("rtpengine", "hash_table_tout", 60)
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "//etc/kamailio/tls.cfg")
#!endif

#!ifdef WITH_SCTP
modparam("sctp", "sctp_assoc_tracking", 0)
modparam("sctp", "sctp_assoc_reuse", 0)
#!endif


#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 50)
modparam("pike", "remove_latency", 30)

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;dmqreplicate=DMQ_REPLICATE_ENABLED;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 0)
modparam("debugger", "log_level_name", "debugger")
# ----- sipdump params -----
modparam("sipdump", "enable", 1)
modparam("sipdump", "wait", 100)
modparam("sipdump", "rotate", 3600)
modparam("sipdump", "folder", "/tmp")
modparam("sipdump", "fprefix", "dsipdump-")
#!endif

#!ifdef WITH_UAC
# ----- uac params -----
modparam("uac", "restore_mode", "none")
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_db_table", "uacreg")
modparam("uac", "reg_timer_interval", 60)
modparam("uac", "reg_retry_interval", 120)
modparam("uac", "reg_keep_callid", 1)
modparam("uac", "reg_gc_interval", 30)
modparam("uac", "credential", "username:domain:password")
modparam("uac", "auth_realm_avp", "$avp(auth_realm)")
modparam("uac", "auth_username_avp", "$avp(auth_user)")
modparam("uac", "auth_password_avp", "$avp(auth_pass)")
modparam("uac", "reg_contact_addr", "UAC_REG_ADDR:SIP_PORT")
# how quickly (in seconds) a RPC reload is allowed
modparam("uac", "reload_delta", 1)
#!endif

#!ifdef WITH_DROUTE
# ----- drouting params -----
modparam("drouting", "db_url", DBURL)
modparam("drouting", "ruri_avp", "$avp(dr_ruri)")
# our convention for passing some data about the selected route:
# attrs[0]: gwid,
# attrs[1]: gwtype
# attrs[2]: msteams domain
# attrs[3]: signalling transport
# attrs[4]: media transport
modparam("drouting", "attrs_avp", "$avp(dr_attrs)")
# don't match on domain (per group) only use routing group
modparam("drouting", "use_domain", 0)
# do not resolve DNS names during load (will blindly try them)
modparam("drouting", "force_dns", 0)
# how gateways are selected from each rule
# 0: destination groups are ignored and all the destinations are tried in the given order
# 1: the destinations from each group are randomly arranged (only the two first elements are randomly selected); groups do maintain their order (as given)
# 2: from each destination group, only a single destination is randomly selected; groups do maintain their order (as given)
modparam("drouting", "sort_order", 0)
# htable for maintenance mode
modparam("htable", "htable", "maintmode=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED;dbtable=dsip_maintmode;cols='ipaddr,gwid';")
#modparam("drouting", "enable_keepalive", 1)
#!endif

#!ifdef WITH_LCR
# ----- htable params for from/to prefix lookup -----
modparam("htable", "htable", "tofromprefix=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED;dbtable=dsip_lcr;cols='pattern,dr_groupid';")
#!endif

# ----- rtimer params -----
#!ifdef WITH_CDRS
modparam("rtimer", "timer", "name=cdr;interval=300;mode=1;")
modparam("rtimer", "exec", "timer=cdr;route=CDRS")
#!endif

# ----- sqlops params -----
# Kamailio Connection
modparam("sqlops", "sqlcon", SQLCONN_KAM)
# Asterisk Realtime Connection
modparam("sqlops", "sqlcon", SQLCONN_AST)

# ----- dialog params -----
modparam("dialog", "db_url", DBURL)
modparam("dialog", "db_mode", 0)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "hash_size", 4096)
modparam("dialog", "detect_spirals", 1)
modparam("dialog", "track_cseq_updates", 1)
modparam("dialog", "default_timeout", 21600)
modparam("dialog", "early_timeout", 300)
modparam("dialog", "noack_timeout", 180)
modparam("dialog", "end_timeout", 60)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "send_bye", 0)
modparam("dialog", "timeout_noreset", 1)
modparam("dialog", "timeout_avp", "$dlg_ctx(timeout)")

#!ifdef WITH_DMQ
# ---- dmq params ----
# TODO: dmq module only supports one server_address so we do not listen on IPV6, possibly change to INTERNAL_FQDN?
#		this would only be an issue for IPv4 disabled machines, which is very uncommon
modparam("dmq", "server_address", "sip:INTERNAL_IP_ADDR:DMQ_PORT")
modparam("dmq", "notification_address", "sip:local.cluster:DMQ_PORT")
modparam("dmq", "multi_notify", 1)
modparam("dmq", "num_workers", 4)
modparam("dmq", "ping_interval", 15)
modparam("dmq_usrloc", "enable", 1)
# ---- dmq-related params ----
modparam("dialog", "enable_dmq", 1)
modparam("htable", "enable_dmq", 1)
# only valid for kam ver >= 5.2
modparam("htable", "dmq_init_sync", 1)
#!endif

#!ifdef WITH_CALL_SETTINGS
modparam("dialog", "profiles_with_value", "gwgroup")
modparam("htable", "htable", "call_settings=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED;dbtable=dsip_call_settings_h;cols='gwgroupid,limit,timeout';colnull='';")
modparam("htable", "htable", "concurrent_calls=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED;initval=0;")
#!endif

# gw2gwroup is used to lookup gwgroupid
modparam("htable", "htable", "gw2gwgroup=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED;dbtable=dsip_gw2gwgroup;cols='gwid,gwgroupid';")
# gwgroup2lb is used to lookup the dispatcher setid associated with a gwgroupid
modparam("htable", "htable", "gwgroup2lb=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED;dbtable=dsip_gwgroup2lb;cols='gwgroupid,setid,enabled';")
# inbound_hardfwd is used to lookup did and dr_groupid for forwarding calls unconditionally
modparam("htable", "htable", "inbound_hardfwd=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED;dbtable=dsip_hardfwd;cols='dr_ruleid,did,dr_groupid';")
# inbound_failfwd is used to lookup did and dr_groupid for forwarding calls on failover
modparam("htable", "htable", "inbound_failfwd=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED;dbtable=dsip_failfwd;cols='dr_ruleid,did,dr_groupid';")
# prefix_to_route is used to lookup dr_ruleid for a prefix
modparam("htable", "htable", "prefix_to_route=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED;dbtable=dsip_prefix_mapping;cols='prefix,ruleid,priority';")
# to manage Pass Thru Auth for Registration. Used to send Authorization requests back to the same backend media server
modparam("htable", "htable", "pass_thru_auth=>size=8;autoexpire=3600;dmqreplicate=DMQ_REPLICATE_ENABLED;")
# enrichdnid_lnpmap is used to lookup dnid prefixes to match against
#!ifdef WITH_DNID_LNP_ENRICHMENT
modparam("htable", "htable", "enrichdnid_lnpmap=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED;dbtable=dsip_dnid_lnp_mapping;cols='dnid,prefix';")
#!endif
# Pass-Thru Auth IP to Domain mapping lookup. Allows PJSIP Pass-Thru to work correctly
#modparam("htable", "htable", "pbxip2domain=>size=8;autoexpire=0;dmqreplicate=DMQ_REPLICATE_ENABLED")

# ----- http_async_client params -----
modparam("http_async_client", "workers", 1)
modparam("http_async_client", "connection_timeout", 500)
modparam("http_async_client", "hash_size", 2048)
#!ifdef WITH_DEBUG
modparam("http_async_client", "curl_verbose", 1)
#!endif
#!ifdef WITH_TLS
modparam("http_async_client", "tls_client_cert", "/etc/dsiprouter/certs/dsiprouter-cert.pem")
modparam("http_async_client", "tls_client_key", "/etc/dsiprouter/certs/dsiprouter-key.pem")
modparam("http_async_client", "tls_ca_path", "/etc/dsiprouter/certs/")
#!endif

# ---- sip trace params ----
#!ifdef WITH_HOMER
modparam("siptrace", "duplicate_uri", "sip:HOMER_HOST:HEP_PORT")
modparam("siptrace", "hep_version", 3)
modparam("siptrace", "hep_mode_on", 1)
modparam("siptrace", "hep_capture_id", HOMER_ID)
modparam("siptrace", "trace_to_database", 0)
modparam("siptrace", "trace_on", 1)
modparam("siptrace", "trace_mode", 1)
modparam("siptrace", "trace_sl_acks", 1)
#!endif


#!ifdef WITH_PUSH
modparam("htable", "htable", "push=>size=10;autoexpire=120;")
#!endif

#======================================================================
# Routing Logic
#======================================================================

# Main SIP request routing logic
# - executed for each SIP request received from the network
# - specific request processing logic should be abstracted into sub-routes
# - sub-routes are defined using the syntax: route[...] { ... }
# - sub-routes can be executed within any routing block
request_route {
#!ifdef WITH_DEBUG
	xlog("L_DBG", "processing request from $sas on $Rut\n");
#!endif

	# handle DMQ messages
	route(DMQ);

	# per request initial checks
	route(REQINIT);

#!ifdef WITH_STIRSHAKEN
	if ((int)$sel(cfg_get.stir_shaken.stir_shaken_enabled)) {
		route(STIRSHAKEN_INBOUND);
	}
#!endif

	# NAT detection
	route(NATDETECT);

	# CANCEL processing
	route(HANDLE_CANCEL);

	# is this request allowed to manage dialogs?
	route(CHECK_DLG_ALLOWED);

	# handle requests within SIP dialogs
	route(WITHINDLG);

	# handle retransmissions
	route(HANDLE_RETRANS);

	# authentication
	route(AUTH);

	# store the call source info for later usage
	route(SET_CALLSRC_INFO);

	# apply NAT changes after dialog is setup
	route(NATMANAGE);

	# handle registrations
	route(REGISTRAR);

	# handle presence related requests
	route(PRESENCE);

	# dispatch to local endpoints that registered thru the proxy
	route(LOCATION);

	# enrich dialed number before routing
	route(ENRICH_DNID);

#!ifdef WITH_TRANSNEXUS
	# Process call if Transnexus validation service is enabled
	if ((int)$sel(cfg_get.transnexus.verifyservice_enabled) && !isflagset(FLT_HAS_TOTAG)) {
		route(TRANSNEXUS_INBOUND);
	}
#!endif

	# route the call to the next hop
	route(NEXTHOP);
}

# Main SIP response handling logic
# - executed for each SIP response received from the network
# - specific reply processing logic should be abstracted into sub-routes
# - onreply routes should not be used here and are only executed when set w/ t_on_reply()
# - sub-routes called here are executed by the core (onreply routes are executed by tm module)
reply_route {
#!ifdef WITH_DEBUG
	xlog("L_DBG", "processing reply from $sas on $Rut\n");
#!endif

	return;
}

# Pre-Send SIP request handling logic
# - executed prior to forwarding specific SIP requests from the network
# - not executed for replies, retransmissions, or locally generated messages
# - a very limited set of core functions are available here, no sub-routes either
onsend_route {
#!ifdef WITH_DEBUG
	xlog("L_DBG", "sending message\n");
#!endif

	return;
}

route[HANDLE_CANCEL] {
	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
	 	route(RTPENGINEDELETE);
		exit;
	}
}

route[HANDLE_RETRANS] {
	if (t_precheck_trans()) {
		t_check_trans();
		exit;
	}
	t_check_trans();
}

route[DMQ] {
#!ifdef WITH_DMQ
	if ($rm == "KDMQ" && $rp == DMQ_PORT) {
		dmq_handle_message();
		exit;
	}
#!endif

	return;
}

route[REFORMATRURI] {
	xlog("L_DBG", "original rU <$rU> and original tU <$tU>\n");

	# This is to deal with those who are used to dialing 7 digits
	# assuming that the 7 digit number being dialed is in the same area code as the FROM number
	if ($(rU{s.len}) == 7) {
		if ($(fU{s.len}) == 10) {
			$rU = $(fU{s.substr,0,3}) + $rU;
		}
		else {
			$rU = $(fU{s.substr,0,4}) + $rU;
		}
		$tU = $rU;
	}
	else if ($(rU{s.len}) > 10) {
		# Check for +1 and remove it from the RURI and the To header
		if ($(rU{s.substr,0,2}) == "+1") {
			$rU = $(rU{s.substr,2,0});
			$tU = $rU;
		}
		# Check for 1 and remove it from the RURI and the To header
		else if ($(rU{s.substr,0,1}) == "1") {
			$rU = $(rU{s.substr,1,0});
			$tU = $rU;
		}
	}

	xlog("L_DBG", "modified rU <$rU> and modified tU <$tU>\n");
}

route[ENRICH_SIPHEADER] {
	if (!strempty($xavp(ra=>sipdomain))) {
		append_hf("X-SIPDOMAIN: $xavp(ra=>sipdomain)\r\n");
	}
}

route[ENRICH_DNID] {
	route(ENRICH_DNID_LNP);
	#route(REFORMATRURI);
}

route[ENRICH_DNID_LNP] {
#!ifdef WITH_DNID_LNP_ENRICHMENT
	# enrich dialed number with country code and area code
	$var(dnid) = $(rU{s.unescape.user});
	$avp(dnid_prefix) = $sht(enrichdnid_lnpmap=>$var(dnid));
	if ($avp(dnid_prefix) != $null && !strempty($avp(dnid_prefix))) {
		$rU = $(avp(dnid_prefix){s.escape.user}) + $rU;
		$tU = $(avp(dnid_prefix){s.escape.user}) + $tU;
	}
#!endif

	return;
}

# Route the call to the next hop, which can be a PBX or Carrier
route[NEXTHOP] {
	######################################
	# Endpoint to PBX via Domain Routing #
	######################################

	# TODO: pbx_type in domain_attrs is not standardized, standardize this in v0.80
	if (isflagset(FLT_DOMAINROUTING) && !isflagset(FLT_EXTERNAL_AUTH)) {
		#Grab the value of the avp that contains the domain_pbx_ip.
		#This is where requests for that domain should be routed

		# Route to the endpoints defined in the Endpoint Gateway list (dr_gw_list)
		if ($avp(domain_pbx_type) == "2") {
			xlog("L_INFO", "<$ci> Routing to Endpoint Gateway List\n");

			if (!strempty($sht(pass_thru_auth=>$ci))) {
				$du = $sht(pass_thru_auth=>$ci);
					xlog("L_INFO", "DOMAINROUTING last du was $du\n");
			}
			# Forward the registration onto one of the servers in the cluster
			else if (!strempty($avp(domain_dispatcher_set_id))) {
				$avp(dispatcher_setid) = $avp(domain_dispatcher_set_id);
				if (!strempty($avp(domain_dispatcher_reg_alg))) {
					# Set the registration algoritm
					$avp(dispatcher_alg) = $avp(domain_dispatcher_reg_alg);
				}
				else {
					# Set the dispatcher algorthim to round robin by default
					$avp(dispatcher_alg) = DSTALG_ROUND_ROBIN;
				}

				route(DISPATCHER_SELECT);
			}
		}
		# Otherwise, send to the single PBX defined by PBX_IP
		else {
			xlog("L_INFO", "DOMAINROUTING Routing to Single Endpoint Gateway\n");
			$du = "sip:" + $avp(domain_pbx_ip);
			# TODO: are these lookups valid here??
			route(SET_CALLDST_INFO);
			route(CHECK_CALL_LIMIT);
			route(SETUP_CALLAUTH_INFO);
		 	route(SETUP_DIALOG);
		}
		xlog("L_INFO", "DOMAINROUTING should be routed to $rd:$rp\n");

		route(RELAY);
		exit;
	}

	#Route to one PBX using an algorithm with External Authentication
	#(aka We are acting as a Registration and Location Server)
	else if (isflagset(FLT_DOMAINROUTING) && isflagset(FLT_EXTERNAL_AUTH) && !is_method("REGISTER")) {
		if (strempty($avp(domain_dispatcher_set_id))) {
			send_reply("404", "Destination Not Found");
			exit;
		}
		else {
			$avp(dispatcher_setid) = $avp(domain_dispatcher_set_id);
			xlog("L_INFO", "DOMAINROUTING Routing for $fd via dispatcher set $avp(dispatcher_setid)\n");
		}

		# set the algorithm to load balancing if not set
		if (strempty($avp(domain_dispatcher_alg))) {
			$avp(dispatcher_alg) = DSTALG_ROUND_ROBIN;
		}
		else {
			$avp(dispatcher_alg) = $avp(domain_dispatcher_alg);
		}

#!ifdef WITH_MSTEAMS
		# check if destination is msteams
		if ($avp(domain_pbx_type) == "3") {
			setbflag(FLB_DST_MSTEAMS);
			$dlg_var(dst_msteams_domain) = $fd;

			# contact must match the domain of the TLS cert (i.e. the CN)
			remove_hf("Contact");
			append_hf("Contact: <sip:$fd:SIPS_PORT;transport=tls>\r\n");
			xlog("L_DBG", "Changed contact to $ct\n");

			# prevent MSTeams from sending REFER requests
			if ((int)$sel(cfg_get.server.msteams_disable_refer)) {
				route(REMOVE_REFER);
			}
			route(DISPATCHER_SELECT);
			route(RELAY);
			exit;
		}
#!endif

		# routing to PBX destination set
		route(ENRICH_SIPHEADER);
		route(DISPATCHER_SELECT);
		route(RELAY);
		exit;
	}

#!ifdef WITH_DROUTE
	######################################
	# From Carrier                       #
	######################################

	# Check if this is coming from carrier
	if (isbflagset(FLB_SRC_CARRIER)) {
		xlog("L_INFO", "The call coming from $si is from a carrier\n");

		# Enrich inbound calls from carriers
		route(ENRICH_CARRIER_INBOUND);

		# Route to PBX
		xlog("L_DBG", "DROUTING Logic for routing to PBX\n");
		append_hf("P-hint: inbound\r\n");
		$avp(calltype) = "inbound";

		# don't overwrite fwding info if we already set it
		if (!isflagset(FLT_FAILOVER)) {
			route(SET_CALLFWD_INFO);
		}

		# don't overwrite dr_groupid if this is n'th time executing this route
		if ($avp(dr_groupid) == $null) {
			# first time executing, save the dialed DID for forwarding features
			$avp(dr_saved_rU) = $rU;

			# check for hard fwd, then set did and dr_groupid accordingly
			if ($avp(hardfwdinfo) != $null) {
				# allow DID to be unchanged
				if (!strempty($(avp(hardfwdinfo){s.select,0,,}))) {
					$rU = $(avp(hardfwdinfo){s.select,0,,});
				}
				$avp(dr_groupid) = $(avp(hardfwdinfo){s.select,1,,}{s.int});
			}
			# otherwise we are using inbound mapping rules
			else {
				$avp(dr_groupid) = FLT_INBOUND;
			}
		}

		# try routing based on rules in dr_rules table
		if (!do_routing($avp(dr_groupid))) {
			xlog("L_WARN", "RURI routing failed, trying to route on the To header\n");
			$rU = $tU;
			# otherwise as a last ditch effort try to route based on To header
			if (!do_routing($avp(dr_groupid))) {
				# No rules defined for the phone number
				xlog("L_WARN", "No rules defined for $rU coming from this carrier endpoint: $si\n");
				sl_reply("500", "No rules defined for number");
				exit;
			}
		}
		# found a match, set du to match what drouting selected
		$du = $(ru{uri.duri});

		route(MAINTMODE_CHECK);
		route(SET_CALLDST_INFO);
		route(CHECK_CALL_LIMIT);
	   	route(SETUP_CALLAUTH_INFO);
		route(SETUP_DIALOG);

		# handle clientside NAT for the rest of the dialog
		# TODO: the other NAT checks are all over the place, we should simplify and aggregate them
		if (nat_uac_test("64")) {
			add_contact_alias();
		}

		# check if routing via dispatcher
		if ($avp(dispatcher_setid) != $null && $avp(lb_enabled)) {
			# dispatcher algo is always weighted here
			$avp(dispatcher_alg) = DSTALG_RELATIVE_WEIGHT;
			route(DISPATCHER_SELECT_LB);
		}

#!ifdef WITH_MSTEAMS
		# Check if routing to MSTeams
		if ($avp(dr_attrs) != $null) {
			if ($(dlg_var(dst_msteams_domain){s.len}) > 0) {
				setbflag(FLB_DST_MSTEAMS);

				# TODO: review in v0.80, do we need to change any of these other headers?
				#if (!subst_hf("Remote-Party-ID", "/^(.*<sips?:[0-9]+@)(.*?)(:?[0-9]{1,5}?>.*)$/\1$dlg_var(dst_msteams_domain)\3/", "f")) {
				#	xlog("L_ERR", "failed updating Remote-Party-ID\n");
				#}
				#
				#$fd = $dlg_var(dst_msteams_domain);
				#$td = $dlg_var(dst_msteams_domain);

				# drouting does not have an easy way to update the transport on a matched address
				# not wasting the time to go through and integrate it into the dr_attrs column
				$du = "sip:" + $rd + ":" + $rp + ";transport=tls";

				# contact must match the domain of the TLS cert (i.e. the CN)
				remove_hf("Contact");
				append_hf("Contact: <sip:$dlg_var(dst_msteams_domain):SIPS_PORT;transport=tls>\r\n");
				xlog("L_DBG", "Changed contact to $ct\n");

				if (is_present_hf("ALLOW")) {

					#Prevent MSTeams from sending REFER requests
					if ((int)$sel(cfg_get.server.msteams_disable_refer)) {
						route(REMOVE_REFER);
					}
				}
				else {
					append_hf("ALLOW: INVITE,ACK,OPTIONS,CANCEL,BYE,NOTIFY\r\n");
				}

				
 

				# set RTP to RTP/SAVP because all MSTeams audio needs to use RTP/SAVP
				$dlg_var(dst_media) = "rtp_savp";
			}
		}
#!endif

		# Set INVITE  max lifetime to ensure Primary and Secondary PBX server feature works.
		t_set_fr((int)$sel(cfg_get.server.pbx_invite_timeout_aftertry), (int)$sel(cfg_get.server.pbx_invite_timeout));

		#route(SET_CALLID_INBOUND_ENDPOINT_MAP);
		route(RELAY);
		exit;
	}

	######################################
 	# To Carrier                         #
 	######################################

	else if (isbflagset(FLB_SRC_PBX) || isflagset(FLT_PBX_AUTH) || isbflagset(FLB_SRC_MSTEAMS)) {
		xlog("L_INFO", "The call coming from $si will be routed to carrier groups via drouting\n");

		append_hf("P-hint: outbound\r\n");
		$avp(calltype) = "outbound";

#!ifdef WITH_LCR
		# LCR Routing
		#   - route based on from prefix and to prefix
		#   - match selection is similar to dRouting module from longest to shortest match
		# Logic Summary:
		#   1. iterate through htable matching entries starting with prefixes
		#   2. find diff between match and lookup (must be absolute value)
		#   3. if diff is less than previous overwrite match
		#   4. if a match is present attempt to set carrier group and relay
		# TODO:
		#   we could store and iterate through all matches if we use dispatcher instead
		#   this would allow failover in LCR Routing to shorter prefixes (if we wanted that)
		$var(lookup) = $(fU{s.unescape.user}) + "-" + $(tU{s.unescape.user});
		$avp(lcr_match_group) = $null;
		$var(lcr_match_diff) = 1000;
		$var(diff) = 1000;

		sht_iterator_start("iter", "tofromprefix");
		while(sht_iterator_next("iter")) {
			$var(regex) = $(shtitkey(iter){s.select,0,-}{re.subst,/(\+|\*|\#)/\\\1/g}) + "([0-9])*-" +
				$(shtitkey(iter){s.select,-1,-}{re.subst,/(\+|\*|\#)/\\\1/g}) + "([0-9])*";
			if ($var(lookup) =~ $var(regex)) {
				xlog("L_DBG", "LCR match on $shtitkey(iter)\n");
				$var(diff) = $(var(lookup){s.len}) - $(shtitkey(iter){s.len});
				# bitwise absolute value: ( mask = n>>31; (mask^n) - mask )
				# we are assuming 32 bit integers
				$var(mask) = $var(diff) >> 31;
				$var(diff) = ($var(mask) ^ $var(diff)) - $var(mask);
				if ($var(diff) < $var(lcr_match_diff)) {
					xlog("L_DBG", "LCR prefix closer match diff=$var(diff)\n");
					$avp(lcr_match_group) = $shtitval(iter);
					$var(lcr_match_diff) = $var(diff);
				}
			}
		}
		sht_iterator_end("iter");

		if ($avp(lcr_match_group) > 0) {
			$avp(carrier_groupid) = $avp(lcr_match_group);
		}
		else {
			$avp(carrier_groupid) = FLT_OUTBOUND;
		}
#!else
		$avp(carrier_groupid) = FLT_OUTBOUND;
#!endif

		if (do_routing($avp(carrier_groupid))) {
			# set du to match what drouting selected
			$du = $(ru{uri.duri});

			route(SET_CALLDST_INFO);
			route(CHECK_CALL_LIMIT);
			route(SETUP_CALLAUTH_INFO);
		 	route(SETUP_DIALOG);

			# Checking if the carrier is using username/password auth
			if (!strempty($dlg_var(dst_auth_domain))) {
				$rd = $dlg_var(dst_auth_domain);
				subst_hf("Contact", "/(.*)?<(sips?):([0-9]+)@([^:]+)(:[0-9]{1,5})?(;.*)?>(.*)?/<\2:\3@UAC_REG_ADDR:$Rp\6>\7/", "f");
				remove_hf("P-Asserted-Identity");
				append_hf("P-Asserted-Identity: <sip:$avp(auth_user)@$rd>\r\n");
			}
			else {
				subst_hf("Contact", "/(.*)?<(sips?):([0-9]+)@([^:]+)(:[0-9]{1,5})?(;.*)?>(.*)?/<\2:\3@EXTERNAL_IP_ADDR:$Rp\6>\7/", "f");
				remove_hf("P-Asserted-Identity");
				append_hf("P-Asserted-Identity: <sip:$fU@$rd>\r\n");
			}

			# drouting only removes prefix from ru, typically we want it removed from the To as well
			uac_replace_from("\"$fU\"", "$rz:$fU@$rd:$rp");
			uac_replace_to("\"$tU\"", "$rz:$tU@$rd:$rp");

			msg_apply_changes();
			if (!isbflagset(FLB_SRC_MSTEAMS)) {	
				add_contact_alias();
			}
			route(ENRICH_CARRIER_OUTBOUND);

			# check if routing via dispatcher
			if ($avp(dispatcher_setid) != $null && $avp(lb_enabled)) {
				# dispatcher algo is always weighted here
				$avp(dispatcher_alg) = DSTALG_RELATIVE_WEIGHT;
				route(DISPATCHER_SELECT_LB);
			}
			route(RELAY);
			exit;
		}
		# No rules defined for the phone number
		else {
			xlog("L_WARN", "No rules defined for $fu going to $tu\n");
			sl_reply("500", "No rules defined for number");
		}
	}
	else {
		sl_send_reply("407", "Proxy Authentication Required. Add the PBX or Carrier IP using GUI");
	}
#!endif
}

route[NEXTHOP_FAILOVER] {
	 # check for failover fwd, then set did and dr_groupid accordingly
	if (($avp(failfwdinfo) != $null) && !isflagset(FLT_FAILOVER)) {
		# flag to make sure we don't loop endlessly
		setflag(FLT_FAILOVER);

		# reset DID if user did not explicitly ask to overwrite it
		if (strempty($(avp(failfwdinfo){s.select,0,,}))) {
			$rU = $avp(dr_saved_rU);
		}
		else {
			$rU = $(avp(failfwdinfo){s.select,0,,});
		}
		$avp(dr_groupid) = $(avp(failfwdinfo){s.select,1,,}{s.int});

		# go back through NEXTHOP to allow our standard routing checks to run for this dr_group
		route(NEXTHOP);
		# we successfully routed via NEXTHOP, return true if we did not exit
		return 1;
	}

	# return false if we did not route the call
	return -1;
}

# MaintMode Check - recursive function for checking if a number is in maintmode
route[MAINTMODE_CHECK] {
	xlog("L_DBG", "The request domain $rd before maintmode check\n");

	if ($sht(maintmode=>$rd) != $null) {
		xlog("L_DBG", "request $rd is in maintenance mode\n");
		# The selected endpoint is in maintenance mode, try next endpoint
		# If there is only one endpoint then immediately return Service not Available
		# Otherwise, select the next gateway and see if it is in maintenance mode
		if (!use_next_gw()) {
			xlog("L_DBG", "request $rd has no other gateways available\n");
			sl_send_reply("503", "Service not available");
			exit;
		}
		# set du to match what drouting selected
		$du = $(ru{uri.duri});

		route(MAINTMODE_CHECK);
	}
}

#!ifdef WITH_TRANSNEXUS
		import_file "transnexus.cfg"
#!endif

#!ifdef WITH_STIRSHAKEN
		import_file "stir-shaken.cfg"
#!endif


# TeleBlock routing
route[TELEBLOCK] {
	if (!isbflagset(FLB_SRC_PBX)) {
		xlog("L_DBG", "source is not a pbx, skipping teleblock blacklist check\n");
		return;
	}

# TODO: This should be dynamic
	# Only route to teleblock if User-to-User header is present
#    if (!is_present_hf("User-to-User")) {
#            xlog("L_DBG", "User-to-User header not found\n");
#            return;
#    }

	# save the requested route selections before overwriting for teleblock
	$avp(tb_saved_fu) = $fu;
	$avp(tb_saved_ru) = $ru;
	$avp(tb_saved_du) = $du;

	# Change source address to this proxy server
	$fu = "sip:" + $fU + "@" + $Ri + ":" + $Rp;

	# Send Invite to TeleBlock with header fields:
	# Number  ==  To Username
	# CPN     ==  From Username
	# BTN     ==  Billing Number (optional)
	# Zipcode ==  US Postal Code (optional)
	# refkey  ==  Record ID      (optional)

	$ru = "sip:" + $rU + "@" + $sel(cfg_get.teleblock.gw_ip) + ":" + $sel(cfg_get.teleblock.gw_port);
	$du = $(ru{uri.duri});

	xlog("L_DBG", "Forwarding to teleblock: fu=$fu ru=$ru du=$du\n");

	# set failure route
	if (is_method("INVITE")) {
		t_on_failure("TELEBLOCK_FAILURE");
	}
}


failure_route[TELEBLOCK_FAILURE] {
	if (t_is_canceled()) {
		exit;
	}

	xlog("L_DBG", "Processing reply for: $rU\n");

	# Check if a media server is setup for teleblock
	if (strempty($sel(cfg_get.teleblock.media_ip)) || strempty($sel(cfg_get.teleblock.media_port))) {
		$avp(s:teleblock_media_enabled) = "0";
	}
	else {
		$avp(s:teleblock_media_enabled) = "1";
	}

	# interpret teleblock response
	if (t_check_status("499")) {
		$fu = $avp(tb_saved_fu);
		$ru = $avp(tb_saved_ru);
		$du = $avp(tb_saved_du);
		t_relay();
		exit;
	}

	xlog("L_DBG", "Relaying to: $sel(cfg_get.teleblock.media_ip):$sel(cfg_get.teleblock.media_port)\n");

	if (t_check_status("403|433")) {
		if ($avp(s:teleblock_media_enabled) == "1") {
			# make sure media server can route back to kamailio
			route(SET_RECORD_ROUTE);
			$ru = "sip:" + $rU + "@" + $sel(cfg_get.teleblock.media_ip) + ":" + $sel(cfg_get.teleblock.media_port);
			if (!t_relay()) {
				t_reply("403", "Do-Not-Contact");
			}
		}
		else {
			if (!t_relay()) {
				t_reply("403", "Do-Not-Contact");
			}
		}
	}
	else {
		if ($avp(s:teleblock_media_enabled) == "1") {
			# make sure media server can route back to kamailio
			route(SET_RECORD_ROUTE);
			$ru = "sip:" + $rU + "@" + $sel(cfg_get.teleblock.media_ip) + ":" + $sel(cfg_get.teleblock.media_port);
			if (!t_relay()) {
				t_reply("500", "Connection Failure");
			}
		}
	}
	exit;
}

# Wrapper for relaying requests
route[RELAY] {
	if (!has_totag()) {
		# update the signalling / media settings per the destination endpoint
		route(SET_DST_SIGNALLING);
		route(SET_DST_MEDIA);
		route(SET_CALLROUTE_INFO);
	}
	 # From WebSocket
        else if (has_totag() && isflagset(FLT_SRC_WS)) {
                # update the signalling / media settings per the destination endpoint
                $dlg_var(dst_media) = "rtp_avp";
                # If $rU is empty
                if ($rU == $null) {
                        $rU = $tU;
                }
                route(SET_DST_SIGNALLING);
                route(SET_DST_MEDIA);

        }
 	# Carrier to MSTeams REINVITE
	#else if (has_totag() && allow_address(FLT_MSTEAMS, "$(du{uri.host})", "$(du{uri.port})")) {
	else if (has_totag() && isbflagset(FLB_DST_MSTEAMS)) {
		
		xlog("L_INFO", "+++ Carrier to MSTeams ru=$ru si=$si, du=$du");
        
	        # update the signalling / media settings per the destination endpoint
                $dlg_var(dst_media) = "rtp_savp";
                route(SET_DST_SIGNALLING);
                route(SET_DST_MEDIA);
		route(SET_CALLROUTE_INFO);
		
		# Set the $ru to the contact from the original INVITE
		#if (is_method("INVITE|ACK") && !allow_address(FLT_MSTEAMS, "$(du{uri.host})", "$(du{uri.port})")) {
		#			$ru = $dlg_var(dst_cturi);
		#}
	        	
		#append_hf("Contact: <sip:$dlg_var(dst_msteams_domain):SIPS_PORT;transport=tls>\r\n");
        }
 	# MSTeams to Carrier REINVITE or REFER
        else if (has_totag() && isbflagset(FLB_SRC_MSTEAMS)) {

            # update the signalling / media settings per the destination endpoint
			$dlg_var(dst_media) = "rtp_avp";
			route(SET_DST_SIGNALLING);
			route(SET_DST_MEDIA);

			xlog("L_INFO", "+++ MSTeams to Carrier ru=$ru si=$si du=$du");
			
			if (is_method("INVITE|ACK") && is_myself($rd)) {
				$ru = $dlg_var(dst_cturi);
			}

			if (is_method("REFER")) {
				route(SET_RECORD_ROUTE);
			}
        }
	# check for serverside NAT
	route(SERVERNATDETECT);
	# only set Record-Route and destination info for dialog creating/updating requests
	if (is_method("INVITE|SUBSCRIBE|REFER") && !has_totag()) {
		route(SET_RECORD_ROUTE);
	}

	if (is_method("NOTIFY|BYE") && is_rfc1918("$rd")) {
                if (!lookup("location","sip:$tU@$td")) {
                        xlog("L_INFO", "Notify Failed - NAT'd address for $tU@$td not found");
                }
        }

	# handle STIR/SHAKEN
#!ifdef WITH_TRANSNEXUS
	if ((int)$sel(cfg_get.transnexus.authservice_enabled)) {
		route(TRANSNEXUS_OUTBOUND);
	}
#!endif

#!ifdef WITH_STIRSHAKEN
	if ((int)$sel(cfg_get.stir_shaken.stir_shaken_enabled)) {
		route(STIRSHAKEN_OUTBOUND);
	}
#!endif

	# Check TeleBlock Blacklist
#!ifdef WITH_TELEBLOCK
	if ((int)$sel(cfg_get.teleblock.gw_enabled)) {
		route(TELEBLOCK);
	}
#!endif


	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if (!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if (!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
		if (!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	# do accounting only for INVITE's
	if (is_method("INVITE")) {
		setflag(FLT_ACC);
	}

	xlog("L_INFO", "Attempting to route call. ru=$ru du=$du fu=$fu tu=$tu\n");
	if (!t_relay()) {
		sl_reply_error();
		route(RTPENGINEDELETE);
	}
	exit;
}

route[CHECK_CALL_LIMIT] {
#!ifdef WITH_CALL_SETTINGS
	# Manage call limits for gwgroups
	xlog("L_DBG", "dst_gwtype: $dlg_var(dst_gwtype), dst_gwid: $dlg_var(dst_gwid), dst_gwgroupid: $dlg_var(dst_gwgroupid) src_gwtype: $dlg_var(src_gwtype), src_gwid: $avp(src_gwid), src_gwgroupid: $dlg_var(src_gwgroupid)\n");

	# if src and dst gwgroup is the same there is no need to check both
	if ($dlg_var(src_gwgroupid) != $dlg_var(dst_gwgroupid)) {
		if (!strempty($xavu(src_call_settings=>limit))) {
			$var(num_calls) = $sht(concurrent_calls=>$dlg_var(src_gwgroupid));
			if ($var(num_calls) >= $xavu(src_call_settings=>limit)) {
				sl_reply("480", "Call Limit Exceeded");
				$avp(notification_type) = NOTIFICATION_OVERLIMIT;
				$avp(notification_gwid) = $dlg_var(src_gwid);
				$avp(notification_gwgroupid) = $dlg_var(src_gwgroupid);
				route(SEND_NOTIFICATION);
				exit;
			}
		}
	}

	if (!strempty($xavu(dst_call_settings=>limit))) {
		$var(num_calls) = $sht(concurrent_calls=>$dlg_var(dst_gwgroupid));
		if ($var(num_calls) >= $xavu(dst_call_settings=>limit)) {
			sl_reply("480", "Call Limit Exceeded");
			$avp(notification_type) = NOTIFICATION_OVERLIMIT;
			$avp(notification_gwid) = $dlg_var(dst_gwid);
			$avp(notification_gwgroupid) = $dlg_var(dst_gwgroupid);
			route(SEND_NOTIFICATION);
			exit;
		}
	}
#!endif

	return;
}

# Per SIP request initial checks
route[REQINIT] {
	# reusable flag denoting the source is an allowed address
	# checking if the flag is already set is a simple optimization for follow-on messages in the transaction
	if (!isflagset(FLT_SRC_ALLOWED)) {
		if (is_myself("$si")) {
			setbflag(FLB_SRC_SELF);
		   	setflag(FLT_SRC_ALLOWED);
	   	}
		else if (allow_source_address_group()) {
			setflag(FLT_SRC_ALLOWED);
	   	}
	}

#!ifdef WITH_ANTIFLOOD
	# if not from self then do flood detection on the source IP
	if (!isbflagset(FLB_SRC_SELF)) {
		if ($sht(ipban=>$si) != $null) {
			# refreshing ip ban
			pike_check_req();
			xlog("L_INFO", "pike blocking request with source address $si:$sp\n");
			exit;
		}
		if (!pike_check_req()) {
			# new ip ban
			xlog("L_ALERT", "pike banning requests from source address $si:$sp\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483", "Too Many Hops");
		exit;
	}

	# Only reply to option messages if the endpoint or the carrier is defined
	if (is_method("OPTIONS") && isflagset(FLT_SRC_ALLOWED)) {
		sl_send_reply("200", "Keepalive");
		exit;
	}

	if (!sanity_check("1511", "7")) {
		xlog("L_WARN", "Malformed SIP message from source address $si:$sp\n");
		exit;
	}

	# request with no Username in RURI, default to the To username
	if ($rU == $null && is_method("INVITE")) {
		$rU = $tU;
	}

	# set a flag denoting the source address type
	# checking if one of the flags is already set is a simple optimization for follow-on messages in the branch
	if (!isbflagset(FLB_SRC_SELF) && !isbflagset(FLB_SRC_PBX) && !isbflagset(FLB_SRC_CARRIER) && !isbflagset(FLB_SRC_MSTEAMS)) {
		if (allow_source_address(FLT_PBX)) {
			setbflag(FLB_SRC_PBX);
		}
		else if (allow_source_address(FLT_CARRIER)) {
			setbflag(FLB_SRC_CARRIER);
		}
		else if (allow_source_address(FLT_MSTEAMS)) {
			setbflag(FLB_SRC_MSTEAMS);
		}
		else if (is_myself("$si")) {
			setbflag(FLB_SRC_SELF);
	   	}
	}

	# set a flag denoting the type of UAC
	if ($pr == "ws" || $pr == "wss") {
		setflag(FLT_SRC_WS);
	}
	else {
		setflag(FLT_SRC_SIP);
	}
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
	# whether we were in a dialog when starting to process this transaction
	if (!has_totag()) {
		resetflag(FLT_HAS_TOTAG);
		return;
	}
	else {
		setflag(FLT_HAS_TOTAG);
	}

	# Logic to handle BLF when using domain routing
	if ( is_method("SUBSCRIBE") ) {
		# Get destination signaling from dialog and replace the transport with that signalling 
		# However, accessing dialog variables seems not to be available when the SIP message 
		# is a subscribe
		#
		#Tested with Polycom VVX phones
		subst("/^Contact:(.*);transport=tcp(.*)/Contact:\1\2/i");
	}

	route(NATMANAGE);

	route(MANAGE_ONHOLD);

	# Handling REINVITES from Carriers to MSTeams
        if (!isbflagset(FLB_SRC_MSTEAMS) && $rd =~ "pstnhub.microsoft.com") {
                setbflag(FLB_DST_MSTEAMS);
        }

	# Handling onhold, but could be used for more
	if (is_method("INVITE") && $hdr(User-Agent) =~ "Microsoft.PSTNHub" && $avp(sdp_media_direction) == "inactive") {
		setbflag(FLB_SRC_MSTEAMS_ONHOLD);
	}


	# sequential request withing a dialog should
	# take the path determined by record-routing
	if (loose_route_mode("1")) {
		# SBC rewrite takes priority
		#route(SBC_TRANSLATE_LR);
		route(DLGURI);

	
		if (is_method("BYE")  && $rd =~ ".invalid")
		{
			if (lookup("location","sip:$tU@$td")) {
				xlog("L_DBG", "Looking up the domain and getting domain: $fd\n");
			}
		}

		if ($(ru{uri.param,transport}) == "ws" || $(ru{uri.param,transport}) == "wss") {

			if (is_method("ACK|BYE|UPDATE|CANCEL")) {

							
				if (!strempty($(ru{uri.param,domain}))) {
				
					$var(domain) = $(ru{uri.param,domain}); 
					$var(exten) = $(ru{uri.param,exten}); 
				}
				else if (!strempty($(tu{uri.param,domain}))) {
				
					$var(domain) = $(tu{uri.param,domain}); 
					$var(exten) = $(tu{uri.param,exten}); 
				}
				else {
					# Use the To domain if domain request param is empty
					$var(domain) = $td;
					$var(exten) = $tU;
				}
				xlog("L_INFO", "Looking up the exten and domain and getting: $var(exten)@$var(domain)\n");
				if (lookup("location","sip:$var(exten)@$var(domain)")) {
					xlog("L_DBG", "Looking up the domain and getting domain: $fd\n");
				}
			
			}
		}

 		# Fix BYE Messages coming from MSTeams to carriers
 		if (isbflagset(FLB_SRC_MSTEAMS) && allow_address(FLT_CARRIER, "$(dlg_var(src_uri){uri.host})", "$(dlg_var(src_uri){uri.port})") && is_method("BYE")) {
                
			$ru = $dlg_var(dst_cturi);
       		 }
	
		# Fix BYE Messages coming from carriers and going to MSTEAMS Domain
         	if (is_method("BYE") && isbflagset(FLB_SRC_CARRIER) && !strempty($dlg_var(src_msteams_domain))) {

 			
		        $ru = $dlg_var(dst_cturi);	
			$td = "sip.pstnhub.microsoft.com";
 			$fd = $dlg_var(src_msteams_domain);
 			remove_hf("Contact");
 			append_hf("Contact: <sip:$dlg_var(src_msteams_domain):SIPS_PORT;transport=tls>\r\n");
         	}

		if (is_method("BYE")) {
			# do accounting even if the transaction fails
			setflag(FLT_ACC);
			setflag(FLT_ACCFAILED);

			route(RTPENGINEDELETE);
		}

		route(RELAY);
		exit;
	}

#!ifdef WITH_MSTEAMS
	# when handling double record route from msteams->dsip->pbx rewrite the destination based on the initial INVITE
	if (isbflagset(FLB_SRC_SELF) && allow_address(FLT_MSTEAMS, "$(dlg_var(dst_uri){uri.host})", "$(dlg_var(dst_uri){uri.port})")) {
		xlog("L_INFO", "handling msteams double record route, rewriting ru from $ru to $dlg_var(src_uri)\n");
		$ru = $dlg_var(src_uri);
	}
#!endif

	if (is_method("SUBSCRIBE") && uri == myself) {
		# in-dialog subscribe requests
		route(PRESENCE);
		exit;
	}

	if (is_method("ACK|UPDATE|INVITE|BYE|PRACK")) {
		# SBC rewrite takes priority
		#route(SBC_TRANSLATE_LR);
		route(DLGURI);

		# Set Accounting flags for strict-routing transactions
		if (is_method("BYE")) {
			setflag(FLT_ACC);
			setflag(FLT_ACCFAILED);

			route(RTPENGINEDELETE);
		}

		# if the message has a transaction try strict routing
		if (t_check_trans()) {
			route(RELAY);
			exit;
		}

		sl_send_reply("481", "Call/Transaction Does Not Exist");
		exit;
	}

	sl_send_reply("604", "Does Not Exist Anywhere");
	exit;
}

# Handle on hold
route[MANAGE_ONHOLD] {
	if (!is_method("INVITE")) {
		return;
	}

	# handle sdp media direction for SBC's/proxies that require on reply
	# rtpengine by default will use a=sendrecv if valid sdp
	if (has_body("application/sdp")) {
		$avp(sdp_media_direction) = $null;

		if (search_body("^a=inactive.*")) {
			$avp(sdp_media_direction) = "inactive";
		}
		else if (search_body("^a=recvonly.*")) {
			$avp(sdp_media_direction) = "recvonly";
		}
		else if (search_body("^a=sendonly.*")) {
			$avp(sdp_media_direction) = "sendonly";
		}
	}
}

# Handle SIP registrations
route[REGISTRAR] {
	if (!is_method("REGISTER")) {
		return;
	}

	# Set the device type if a WS device
	# TODO: the type of UAC won't change in the middle of a transaction, marked for review/removal
	if (isflagset(FLT_SRC_WS)) {
		setbflag(FLB_WS_DEVICE);
	}

	# TODO: why are we setting clientside NAT here if serverside NAT is enabled?
#!ifdef WITH_SIGNAL_SERVERNAT
	setbflag(FLB_NATB);
#!endif
#!ifdef WITH_SIGNAL_SERVERNAT6
	setbflag(FLB_NATB);
#!endif
#!ifdef WITH_NAT
	# do SIP NAT pinging via OPTIONS messages
	setbflag(FLB_NATSIPPING);
#!endif

	if (isflagset(FLT_PBX_AUTH)) {
		# Handle Register Event - We are now acting as a REGISTRAR.
		if (!save("location")) {
			sl_reply_error();
		}

		# TODO: can we move these to in memory changes
		# Update dr_gateways and dr_gw_lists accordingly
		if ($sel(contact.expires) == "0") {
			xlog("L_DBG", "received an unregister request\n");
			if (!strempty($dlg_var(src_gwid))) {
				xlog("L_DBG", "removing registration address $var(received_addr) from gateways for gwgroup $dlg_var(src_gwgroupid)\n");

				sql_query("kam", "DELETE FROM dr_gateways WHERE gwid='$dlg_var(src_gwid)'");
				sql_query("kam", "UPDATE dr_gw_lists SET gwlist=REGEXP_REPLACE(REGEXP_REPLACE(gwlist, '([,;])?$dlg_var(src_gwid)', ''), '^([,;])', '') WHERE id=$dlg_var(src_gwgroupid)");

				jsonrpc_exec('{"jsonrpc": "2.0", "method": "drouting.reload", "id": 1}');
			}
		}
		else {
			xlog("L_DBG", "received an register request\n");
			if (strempty($dlg_var(src_gwid))) {
				xlog("L_DBG", "adding registration address $var(received_addr) to gateways for gwgroup $dlg_var(src_gwgroupid)\n");

				sql_query("kam", "INSERT INTO dr_gateways(type,address,attrs,description) VALUES ($dlg_var(src_gwtype),'$var(received_addr)',',,,proxy,proxy','name:autoregister,type:$dlg_var(src_gwtype),gwgroup:$dlg_var(src_gwgroupid)');");
				sql_query("kam", "UPDATE dr_gw_lists SET gwlist=REGEXP_REPLACE(CONCAT(gwlist,',',(SELECT MAX(gwid) FROM dr_gateways)), '^,', '') WHERE id=$dlg_var(src_gwgroupid)");

				jsonrpc_exec('{"jsonrpc": "2.0", "method": "drouting.reload", "id": 1}');
			}
		}

		exit;
	}

	if (isflagset(FLT_DOMAINROUTING) && !isflagset(FLT_EXTERNAL_AUTH)) {
		# Save the location, but DON'T send a 200 reply back.
		# Let the upstream PBX authenticate the UAC (aka endpoint)

		if (!save("location", "0x02")) {
			sl_reply_error();
		}

		# Keep the origin request domain
		$var(rd_orig) = $rd;

		# Route to the endpoints defined in the Endpoint group (using dispatcher)
		if ($avp(domain_pbx_type) == "2") {
			#Forward the registration onto one of the servers in the cluster
			if (!strempty($avp(domain_dispatcher_set_id))) {
				$avp(dispatcher_setid) = $avp(domain_dispatcher_set_id);
				if (!strempty($avp(domain_dispatcher_reg_alg))) {
					# Set the registration algoritm
					$avp(dispatcher_alg) = $avp(domain_dispatcher_reg_alg);
				}
				else {
					# Set the dispatcher algorthim to round robin by default
					$avp(dispatcher_alg) = DSTALG_ROUND_ROBIN;
				}

				if (!strempty($sht(pass_thru_auth=>$ci))) {
					$du = $sht(pass_thru_auth=>$ci);
					xlog("L_INFO", "DOMAINROUTING last du was $du\n");
				}
				else {
					route(DISPATCHER_SELECT);
					xlog("L_INFO", "DOMAINROUTING Routing to Endpoint Gateway List $avp(dispatcher_setid)\n");
				}
			}
		}
		else {
			# Grab the value of the avp that contains the domain_pbx_ip.
			# This is where requests for that domain should be routed

			                  $var(rd) = $(avp(domain_pbx_ip){s.select,0,:});
                        $var(portandtransport) = $(avp(domain_pbx_ip){s.select,1,:});

                        if (strempty($var(portandtransport))) {
                                $var(rp) = "5060";
                        }
                        else {

                        	$var(rp) = $(var(portandtransport){s.select,0,;});
                        	$var(transport) = $(var(portandtransport){s.select,1,;});

                        }

                        if (strempty($var(transport))) {


                                $ru = $rz + ":" + $var(rd) + ":" + $var(rp);
                        }
                        else {
                                $ru = $rz + ":" + $var(rd) + ":" + $var(rp) + ";" + $var(transport);
                        }
		}
	
		# Rewrite Contact based on the domain being routed to
		$var(ct_domain) = $fd;
		route(REPLACE_CONTACT_DOMAIN);

		if (isbflagset(FLB_WS_DEVICE)) {
			add_path();
		}
		else {
			#Add the Path header for SIP UAS know how to route back
                        if (!strempty($var(transport))) {
				add_path($fU, $var(transport));
			}
			else {
				add_path($fU);

			}
		}

		# Store the pbx ip to domain mapping so that SIP messages from the PBX can be rewritten
		if (!is_ip($(avp(domain_pbx_ip){s.select,0,:}))) {
			if (dns_query($(avp(domain_pbx_ip){s.select,0,:}), "xyz")) {
				$var(i) = 0;
				while ($var(i) < $dns(xyz=>count)) {
					$sht(pass_thru_auth=>$dns(xyz=>addr[$var(i)])) = $var(rd_orig);
					$var(i) = $var(i) + 1;
				 }
			}
		}
		else {
			$sht(pass_thru_auth=>$(avp(domain_pbx_ip){s.select,0,:})) = $var(rd_orig);
		}

		#We are going to pass this request on to the backend server
		route(RELAY);
		exit;
	}
	else if (isflagset(FLT_DOMAINROUTING) && isflagset(FLT_EXTERNAL_AUTH)) {
		if (!save("location")) {
			sl_reply_error();
		}
		exit;
	}


#!ifdef WITH_PUSH
   if (($hdr(Expires) != "0") || !($hdr(Contact) =~ "expires=0") && ($sht(push=>join::$tU@td) != $null)) {
		xlog("L_INFO", "[REGISTER] [PUSH] about to un-suspend transaction rm=$rm ru=$ru tU=$tU td=$td \n");
  		route(JOIN);
	}
#!endif

	#    #Forward the registration onto one of the servers in the cluster
	#    if (!strempty($avp(domain_dispatcher_set_id))) {
	#        $avp(dispatcher_setid) = $avp(domain_dispatcher_set_id);
	#        if (!strempty($avp(domain_dispatcher_reg_alg))) {
	#            #Set the registration algoritm
	#            $avp(dispatcher_alg) = $avp(domain_dispatcher_reg_alg);
	#        }
	#        else {
	#            #Set the dispatcher algorthim to round robin by default
	#            $avp(dispatcher_alg) = DSTALG_ROUND_ROBIN;
	#        }
	#
	#        route(DISPATCHER_SELECT);
	#        route(RELAY);
	#    }
	#    exit;
	#}
}

# Dispatcher request load balancing (we don't route here)
route[DISPATCHER_SELECT] {
	# round robin dispatching on dispatcher gateways set
	if (!ds_select_dst($avp(dispatcher_setid), $avp(dispatcher_alg))) {
		xlog("L_ERR", "no destination selected for domain: $fd\n");
		send_reply("404", "Destination Not Found");
		exit;
	}

	if (strempty($xavp(dispatcher_dst=>uri)) && $avp(dispatcher_alg) == DSTALG_PARALLEL_FORKING) {
		xlog("L_DBG", "sending to multiple servers in parallel\n");
	}
	else if (!strempty($xavp(dispatcher_dst=>uri))) {
		xlog("L_DBG", "dispatcher selected $xavp(dispatcher_dst=>uri)\n");
	}

	t_on_failure("DISPATCHER_NEXT");
	return;
}

failure_route[DISPATCHER_NEXT] {
	# try next destionations in failure route
	if (t_is_canceled()) {
		route(RTPENGINEDELETE);
		exit;
	}
	if (t_check_status("401|407")) {
		xlog("L_INFO", "DOMAINROUTING 401 or 407 and the du was $du)\n");
		$sht(pass_thru_auth=>$ci) = $du;
		return;
	}
	# next DST - only for 500 or local timeout
	if (t_check_status("4[0-9][2-6,8-9]|5[0-9][0-9]") or (t_branch_timeout() and !t_branch_replied())) {
		if (ds_next_dst()) {
			xlog("L_DBG", "dispatcher selected $xavp(dispatcher_dst=>uri)\n");
			t_on_failure("DISPATCHER_NEXT");
			route(RELAY);
			return;
		}
		else {
			# Drop the replies if this is a REGISTER
			if (is_method('REGISTER')) {
				t_drop_replies();
				t_reply("401", "Unauthorized");
			}
		}
	}
}

route[DISPATCHER_SELECT_LB] {
	# dispatch using the selected algorithm for this endpoint group
	if (!ds_select_dst($avp(dispatcher_setid), $avp(dispatcher_alg))) {
		xlog("L_WARN", "no destination selected for dispatcher set $avp(dispatcher_setid)\n");

		# check failover forwarding, otherwise reply with an error
		if (!route(NEXTHOP_FAILOVER)) {
			send_reply("600", "No Destination Found");
			exit;
		}

		# if for some reason the failover forwarding was successful but did not exit then we return to calling routine
		return;
	}

	# rewrite domain / port in request URIs
	$ru = $rz + ":" + $rU + "@" + $dd + ":" + $dp;
	$tu = $rz + ":" + $rU + "@" + $dd + ":" + $dp;
	# we have to flush the buffer in case other changes are/were made
	msg_apply_changes();

	t_on_failure("DISPATCHER_NEXT_LB");
	return;
}

failure_route[DISPATCHER_NEXT_LB] {
	# try next destinations in failure route
	if (t_is_canceled()) {
		route(RTPENGINEDELETE);
		exit;
	}
	# next DST 
	if (t_check_status("4[0-9][1-6,7-9]|5[0-9][0-9]") || (t_branch_timeout() && !t_branch_replied())) {
		if (ds_next_dst()) {
		 	xlog("L_DBG", "trying next destination\n");

			# rewrite domain / port in request URIs
			$ru = $rz + ":" + $rU + "@" + $dd + ":" + $dp;
			$tu = $rz + ":" + $rU + "@" + $dd + ":" + $dp;

			t_on_failure("DISPATCHER_NEXT_LB");
			route(RELAY);
		}
		else {
			xlog("L_INFO", "all destinations unavailable for dispatcher set $avp(dispatcher_setid)\n");

			# check failover forwarding, otherwise reply with an error
			if (!route(NEXTHOP_FAILOVER)) {
				send_reply("600", "No Destination Available");
				route(RTPENGINEDELETE);
				exit;
			}

			# if for some reason the failover forwarding was successful but did not exit then we return to calling routine
			return;
		}
	}
	exit;
}

# User location service
route[LOCATION] {

	# Return immediately if the source address is not a PBX.  Only PBX's should be trying to route to endpoints
	if (!isbflagset(FLB_SRC_PBX)) {
		return;
	}

	# Emergency / N11 services should return immediately so that it can be routed to a carrier
	# ITU officially recognizes 911 (NA) and 112 (EU) as the international emergency numbers
	# However 999 (UK) and 000 (AU) are still commonly used
	# Emergency Numbers Overview: https://en.wikipedia.org/wiki/Emergency_telephone_number
	# N11 Ref: https://nationalnanpa.com/number_resource_info/n11_codes.html
	# On 2020-Jul-16 the FCC also adopted 988 as an N11 number
	# 988 Adoption Refs: https://www.fcc.gov/document/fcc-designates-988-national-suicide-prevention-lifeline
	if ($rU =~ $sel(cfg_get.server.emergency_numbers)) {
		return;
	}
	
	# Set the extension and request domain for WebSocket request because some
	# WebSocket clients don't send the extension and domain during registeration
	if (!strempty($(ru{uri.param,domain}))) { 

		$rU = $(ru{uri.param,exten});
		$rd = $(ru{uri.param,domain});
	} 

	# Return if the rU is more then local calling maximum digits for the initiating PBX
	if ($(rU{s.len}) > $sel(cfg_get.server.pbx_max_local_digits)) {
		return;
	}

	# If request is coming from a FreePBX or Asterisk server use the Pass-Thru htable
	if ($hdr(User-Agent) =~ "FPBX.*|Asterisk.*") {
		if ($sht(pass_thru_auth=>$si) != "") {
			$rd = $sht(pass_thru_auth=>$si);
		}
	}

	# Logic to to deal with a broken PATH implmentation in Asterisk PJSIP
	if (!strempty($(ru{uri.param,x-ast-orig-host}))) { 
		$var(asterisk_domain) = $(ru{uri.param,x-ast-orig-host});
		$var(asterisk_domain) = $(var(asterisk_domain){re.subst,/^(.*):(.*)/\1/});
	
		if ($var(asterisk_domain) != "") {
			$rd = $var(asterisk_domain);
			if (!msg_apply_changes()) {
				xlog("L_ERR", "failed applying changes to message\n");
			}
			xlog("L_INFO", "routing message for domain $var(asterisk_domain) to $rU@$rd\n");
		}
		xlog("L_INFO", "routing message for domain $var(asterisk_domain) to $rU@$rd\n");
	}

	$avp(oexten) = $rU;
	# Lookup the location of the endpoint by username@request_domain
	if (!lookup("location","sip:$rU@$rd")) {

#!ifdef WITH_PUSH
		xlog("L_INFO", "  In the route[LOCATION] [PUSH] logic.");
		send_reply("100", "Suspending");
		route(SENDPUSH);
		route(SUSPEND);
#!endif

		# Lookup the location of the endpoint by username@from_domain
		if (!lookup("location","sip:$rU@$fd")) {
			# Check if coming from a Zoiper Push Server
			# If so, the username for the extension is part of the Route header, grab it
			$var(Route) = @hf_value.route.uri;
			$var(user) = $(var(Route){uri.user});
			xlog("L_DBG", "$var(Route) / sip:$var(user)@$fd\n");
			if (!lookup("location", "sip:$var(user)@$fd")) {
				$var(rc) = $rc;
				route(TOVOICEMAIL);
				t_newtran();
				switch ($var(rc)) {
					case -1:
					case -3:
						send_reply("404", "Not Found");
						exit;
					case -2:
						send_reply("405", "Method Not Allowed");
						exit;
				}
			}

			xlog("L_INFO", "ru: $ru, nh(u): $nh(u), WS:$var(WS_DEVICE)\n");
		}
	}

	$var(transport) = $(ru{uri.param,transport});
	xlog("L_INFO", "The transport is $var(transport)");	
	# Set the Signalling and Media
	if ($(ru{uri.param,transport}) != $null) { 
		$var(transport) = $(ru{uri.param,transport});
		xlog("L_INFO", "The transport is $var(transport)");	
		switch ($(var(transport){s.tolower}))  {

			case "wss":
				$dlg_var(dst_signalling) = "sips_wss";
				$dlg_var(dst_media) = "rtp_savp";
				setflag(FLB_WS_DEVICE);
				break;
			case "ws":
				$dlg_var(dst_signalling) = "sip_ws";
				$dlg_var(dst_media) = "rtp_savp";
				setflag(FLB_WS_DEVICE);
				break;
			case "udp":
				$dlg_var(dst_media) = "rtp_avp";
				$dlg_var(dst_signalling) = "udp";			
				break;		
			default:
				$dlg_var(dst_media) = "proxy";
				$dlg_var(dst_signalling) = "proxy";			
				break;
				
		}
		
		
	}

	# when routing via usrloc, log the missed calls also
	if (is_method("INVITE")) {
		setflag(FLT_ACCMISSED);
	}
	#Set the INVITE timeout for sending calls to invites
	t_set_fr(120000,10000);

	route(SET_CALLDST_INFO);
	route(RELAY);
	exit;
}

#!ifdef WITH_PUSH
# Suspend Transaction
route[SUSPEND] {
	xlog("L_INFO", "suspending transaction\n");
	t_set_fr(30000);

	if (!t_suspend()) {
		xlog("L_ERR", "failed suspending trasaction [$T(id_index):$T(id_label)]\n");
		send_reply("501", "Unknown destination");
		exit;
	}

	xlog("L_INFO", "suspended transaction [$T(id_index):$T(id_label)] $fU => $rU@$rd\n");
	$sht(push=>join::$rU@$rd) = "" + $T(id_index) + ":" + $T(id_label);
	xlog("L_INFO", "suspended htable key value [$sht(push=>join::$rU@$rd)]\n");
	exit;
}

# Logic to invoke push
route[SENDPUSH] {
	xlog("L_INFO", "sending the push notification\n");
	#rabbitmq_publish("kamailio", "routing_key", "application/json", "$avp(json_request)");

	#$var(luaret) = 0;
	#if(lua_runstring("do_push([[$hdr(X-VxTo)]], [[$tU]], [[$hdr(X-VxFrom)]], [[$fU]], [[$ci]])")<0){
	#	send_reply("501", "No link to destination");
	#	exit;
	#}
	return;
}

# Suspend
route[JOIN] {
 	xlog("L_INFO", "  In the [PUSH] route[JOIN] logic.");
	$var(index)=(int) $(sht(push=>join::$tU@$td){s.select,0,:});
	$var(label)=(int) $(sht(push=>join::$tU@$td){s.select,1,:});
	xlog("L_INFO", "[JOIN] [PUSH] suspend $var(index) $var(label)");
	t_set_fr(30000);
	t_continue("$var(index)", "$var(label)", "RESUME");
}

# Resume
route[RESUME] {
	xlog("L_INFO", "resuming transaction");

	xlog("L_INFO", "values before lookup: rm=$rm ru=$rU rd=$rd du=$du \n");
	if (!lookup("location","sip:$rU@$rd")) {
		switch ($retcode) {
			case 1:
				xlog("L_INFO", "values after lookup rm=$rm ru=$rU rd=$rd du=$du \n");
			case -1:
			case -3:
				sl_send_reply("404", "Not Found");
				exit;
				break;
			case -2:
				sl_send_reply("405", "Not Found");
				exit;
				break;
		}
	}

	xlog("L_INFO","[RESUME] [PUSH] suspend rm=$rm ru=$rU rd=$rd du=$du \n");
	record_route();
	t_relay();
	exit;
}
#!endif


# Presence server processing
route[PRESENCE] {
	if (!is_method("PUBLISH|SUBSCRIBE")) {
		return;
	}

	if (is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
		route(TOVOICEMAIL);
		# returns here if no voicemail server is configured
		sl_send_reply("404", "No voicemail service");
		exit;
	}

#!ifdef WITH_PRESENCE
	if (isflagset(FLT_DOMAINROUTING) && !isflagset(FLT_EXTERNAL_AUTH)) {
		# Rewrite Contact based on the domain being routed to
		$var(ct_domain) = $fd;
		route(REPLACE_CONTACT_DOMAIN);
    }
	if (!t_newtran()) {
		sl_reply_error();
		exit;
	}

	if (is_method("PUBLISH")) {
		handle_publish();
		t_release();
	}
	else if (is_method("SUBSCRIBE")) {
		handle_subscribe();
		t_release();
	}
	exit;
#!endif

	# if presence enabled, this part will not be executed
	if (is_method("PUBLISH") || $rU == $null) {
		sl_send_reply("404", "Not here");
		exit;
	}
	return;
}

# IP authorization and user authentication
route[AUTH] {
#!ifdef WITH_AUTH
	if (is_myself("$si")) {
		return;
	}

	# AUTH route logic summary:
	# 1) attempt domain auth
	# 2) Check if request is coming from a carrier that's using username/password auth (remote or local)
	# 3) attempt IP auth
	# 4) attempt username/password auth against local subscriber database

	#=================
	# Domain AUTH
	#=================
	# Check if this is any type of SIP request from a known domain only if the role of the server is not "inout".
	# The role of "inout" means that the role of this Kamailio instance is to just route calls inbound and outbound
	# using only IP auth or username/password auth

	if (lookup_domain("$fd", "domain_") && ($sel(cfg_get.server.role) != 'inout')) {
		# Turn on domain routing by setting the FLT_DOMAINROUTING flag
		setflag(FLT_DOMAINROUTING);

		# If the domain is mapped to single PBX then route to the PBX IP for authentication
		if ($avp(domain_domain_auth) == "passthru") {
			setflag(FLT_PASSTHRU_AUTH);
			xlog("L_INFO", "DOMAIN_AUTH $tU@$fd will be routed to $avp(domain_pbx_ip)\n");
			return;
		}
		#Check if the domain is configured to route to a cluster of PBX's by checking if the dispatcher set_id is set
		#If so, we need to auth the user against an external database or local subscriber database
		#This will allow INVITE requests to be sent to any backend PBX's because we have validated the user
		#Hence, the backend PBX's should be setup only to trust SIP connections from dSIPRouter instances
		else if (!strempty($avp(domain_dispatcher_set_id))) {
			$avp(dispatcher_setid) = $avp(domain_dispatcher_set_id);
			if (is_method("REGISTER|INVITE") || from_uri==myself) {
				# Each domain has a auth type thats external to the backend destination server
				# 1 = Kamailo Subscriber table
				# 2 = Asterisk DB

				setflag(FLT_EXTERNAL_AUTH);

				xlog("L_INFO", "Generic Domain Routing for $tU@$fd - the defined auth type for $fd is $avp(domain_domain_auth)\n");

				if ($avp(domain_domain_auth) == "realtime") {
					xlog("L_INFO", "DOMAIN_AUTH Asterisk Realtime auth is being used\n");
					# Load data needed for custom SIP headers
					if ($avp(domain_enrich_headers) == 1) {
						$var(query) = "select sippasswd,sipdomain from sipusers where name=$fU";
					}
					else {
						$var(query) = "select sippasswd from sipusers where name=$fU";
					}

					#Let's auth against the database defined by the domain attributes
					sql_xquery("asterisk","$var(query)","ra");
					$var(sippasswd) = $xavp(ra=>sippasswd);
					sql_result_free("ra");
					xlog("L_DBG", "DOMAIN_AUTH The password for user $fU@$fd is $var(sippasswd)\n");

					if (!pv_auth_check("$fd", "$xavp(ra=>sippasswd)", "2","0")) {
						auth_challenge("$fd", "0");
						exit;
					}
				}
				else if ($avp(domain_domain_auth) == "local") {
					xlog("L_INFO", "DOMAIN_AUTH Local auth is being used\n");
					if (!auth_check("$fd", "subscriber", "3")) {
					   auth_challenge("$fd", "0");
					   exit;
					}
				}
				# TODO: return error if domain_dispatcher_set_id is set and domain_domain_auth not realtime or local?
			}
			# user authenticated - remove auth header
			if (!is_method("REGISTER|PUBLISH")) {
				xlog("L_INFO", "DOMAIN_AUTH $tU@$fd was authenticated\n");
				consume_credentials();
			}

			return;
		}
	}

	#=================
	# Digest AUTH
	#=================
	if (is_subscriber("$fu", "subscriber", "3")) {
		# authenticate requests
		if (!auth_check("$fd", "subscriber", "3")) {
			auth_challenge("$fd", "0");
			exit;
		}
		# user authenticated - remove Authorization header
		consume_credentials();

		# set flags denoting what auth/src we have
		setflag(FLT_PBX_AUTH);
		setbflag(FLB_SRC_PBX);
		return;
	}

	#=================
	# IP AUTH
	#=================
#!ifdef WITH_IPAUTH
	# If domain not known, then check IP AUTH to see if the user if allowed to connect
	# Changed from allow_source_address to allow_source_addess_group because it will allow any addresses within any address group.
	# This means that both carriers and pbx's will be allowed to access the proxy with one function call
	# TODO: we already check source address in REQINIT, why are we checking again here?
	if (isflagset(FLT_SRC_ALLOWED)) {
		# source IP allowed
		return;
	}
#!endif

	if (is_method("REGISTER|INVITE") || from_uri==myself) {
		# authenticate requests
		if (!auth_check("$fd", "subscriber", "3")) {
			auth_challenge("$fd", "0");
			exit;
		}
		# user authenticated - remove auth header
		if (!is_method("REGISTER|PUBLISH")) {
			consume_credentials();
		}
		# Set a flag denoting that a PBX has authenticated with username/password
		setflag(FLT_PBX_AUTH);
	}
#!endif

	return;
}

route[SET_CALLSRC_INFO] {
	# source request info for manipulating what we send to UAC later in the transaction/dialog
	$dlg_var(src_oruri) = $ru;
	$dlg_var(src_ofuri) = $fu;
	$dlg_var(src_oturi) = $tu;
	$dlg_var(src_duri) = $sut;

	$var(received_addr) = $(su{re.subst,/^(sip:|sips:)?(.*)$/\2/});

	if (isbflagset(FLB_SRC_MSTEAMS)) {
		$dlg_var(src_msteams_domain) = $td;
	}

	# Set call info for tracking call limits for username/pass auth
	if (isflagset(FLT_PBX_AUTH)) {
		if (sql_xquery("kam", "select rpid as gwgroupid from subscriber where username='$au'", "rows") == 1) {
			$dlg_var(src_gwtype) = (str)FLT_PBX;
			$dlg_var(src_gwgroupid) = $xavp(rows=>gwgroupid);
			if (sql_xquery("kam", "select gwid from dr_gateways where address='$var(received_addr)' AND description REGEXP 'gwgroup:$dlg_var(src_gwgroupid)(,|$$)'", "rows") == 1) {
				$dlg_var(src_gwid) = $xavp(rows=>gwid);
			}
		}
	}
	# TODO: these assumptions here are broken throughout the codebase, marked for review in v0.80
	else if (isflagset(FLT_DOMAINROUTING)) {
		$dlg_var(src_gwtype) = $avp(domain_pbx_type);
		$dlg_var(src_gwgroupid) = $avp(domain_pbx_list);
	}
	# Set call info for tracking call limits for ip auth
	else {
		if (sql_xquery("kam","select type, gwid from dr_gateways where address like '$si%'", "rows") == 1) {
			$dlg_var(src_gwtype) = $xavp(rows=>type);
			$dlg_var(src_gwid) = $xavp(rows=>gwid);
			$dlg_var(src_gwgroupid) = $sht(gw2gwgroup=>$dlg_var(src_gwid));
		}
	}

#!ifdef WITH_CALL_SETTINGS
	$vn(call_settings) = $sht(call_settings=>$dlg_var(src_gwgroupid));
	if ($vn(call_settings) != $null) {
		$xavu(src_call_settings=>limit) = $(vn(call_settings){s.select,0,,});
		$xavu(src_call_settings=>timeout) = $(vn(call_settings){s.select,1,,});
	}
	else {
		$xavu(src_call_settings=>limit) = "";
		$xavu(src_call_settings=>timeout) = "";
	}
#!endif

	# set call forwarding info to null by default
	$avp(hardfwdinfo) = $null;
	$avp(failfwdinfo) = $null;

	return;
}

# once a destination is selected route here to get more detailed info about the gwgroup
route[SET_CALLDST_INFO] {
	if ($avp(dr_attrs) != $null) {
		$var(dst_gwid) = $(avp(dr_attrs){s.select,0,,});
		$var(dst_gwtype) = $(avp(dr_attrs){s.select,1,,});
		$var(dst_msteams_domain) = $(avp(dr_attrs){s.select,2,,});
	 	$var(dst_signalling) = $(avp(dr_attrs){s.select,3,,});
	 	$var(dst_media) = $(avp(dr_attrs){s.select,4,,});
		$var(dst_gwgroupid) = $sht(gw2gwgroup=>$var(dst_gwid));
		# by convention the setid is the same as the gwgroupid
		if (!strempty($var(dst_gwgroupid))) {
			$avp(dispatcher_setid) = $var(dst_gwgroupid);
		}
		else {
			$avp(dispatcher_setid) = $null;
		}

		# special use case: Set the media to rtp_avp if coming from MSTeams and the dst media is set to proxy
		if (!strempty($var(src_msteams_domain)) && $var(dst_media) == "proxy") {
			$var(dst_media) = "rtp_avp";
		}
	}
	else if (isflagset(FLT_PASSTHRU_AUTH)) {
		# passthru auth only maps to a single pbx
		$var(dst_gwid) = $(avp(domain_pbx_list){s.select,0,,});
		sql_pvquery(
			"kam",
			"SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(attrs, ',', 2), ',', -1), SUBSTRING_INDEX(SUBSTRING_INDEX(attrs, ',', 3), ',', -1), SUBSTRING_INDEX(SUBSTRING_INDEX(attrs, ',', 4), ',', -1), SUBSTRING_INDEX(SUBSTRING_INDEX(attrs, ',', 5), ',', -1), REGEXP_REPLACE(description, '.*gwgroup:([0-9]+).*', '\\1') FROM dr_gateways WHERE gwid='$var(dst_gwid)'",
			"$var(dst_gwtype), $var(dst_msteams_domain), $var(dst_signalling), $var(dst_media), $var(dst_gwgroupid)"
		);
		
		# Check if Source is WebSocket and $var(dst_media) = proxy.  If so, set $var(dst_media) = rtp_avp as the default
		if (isflagset(FLT_SRC_WS) && $var(dst_media) == "proxy")  {
			$var(dst_media) = "rtp_avp";
		}
	
	}
	else {
		xlog("L_ERR", "can not lookup destination info\n");
		return;
	}

	$vn(gwgroup2lb) = $sht(gwgroup2lb=>$var(dst_gwgroupid));
	if ($vn(gwgroup2lb) != $null) {
		$avp(lb_enabled) = (int)$(vn(gwgroup2lb){s.select,1,,});
	}
	else {
		$avp(lb_enabled) = 0;
	}

#!ifdef WITH_CALL_SETTINGS
	$vn(call_settings) = $sht(call_settings=>$var(dst_gwgroupid));
	if ($vn(call_settings) != $null) {
		$xavu(dst_call_settings=>limit) = $(vn(call_settings){s.select,0,,});
		$xavu(dst_call_settings=>timeout) = $(vn(call_settings){s.select,1,,});
	}
	else {
		$xavu(dst_call_settings=>limit) = "";
		$xavu(dst_call_settings=>timeout) = "";
	}
#!endif

	# dialog lookups are computationally expensive, therefore we set them last after checks above
	$dlg_var(dst_gwid) = $var(dst_gwid);
	$dlg_var(dst_gwtype) = $var(dst_gwtype);
	$dlg_var(dst_msteams_domain) = $var(dst_msteams_domain);
	$dlg_var(dst_signalling) = $var(dst_signalling);
	$dlg_var(dst_media) = $var(dst_media);
	$dlg_var(dst_gwgroupid) = $var(dst_gwgroupid);
}

# store the selected du/ru and reformatted contact
route[SET_CALLROUTE_INFO] {
	$dlg_var(dst_ruri) = $ru;
	$dlg_var(dst_duri) = $du;
	
	if (!has_totag() && is_method("INVITE")) {
		if ($ct =~ "<.*>") {
			
			$dlg_var(dst_cturi) = $(ct{re.subst,/^<(.*)>/\1/});
		}
		else {
			
			$dlg_var(dst_cturi) = $ct;
		}	
	}

}

# TODO: we should avoid recreating the drouting algo here and instead check hardfwd and failfwd dr_group by default
# drouting would be called 3 times by default in this case, satisfying the following logic:
# 1. check hardfwd dr_group for prefix matches
# 2. check default dr_group for prefix matches (pbx or carrier)
# 3. check failfwd dr_group for prefix matches
# this would avoid prefix match prediction as we do below and support time criteria by default
route[SET_CALLFWD_INFO] {
	# we need to know what prefix drouting will match before it runs
	# this only checks against inbound rules, this shouldn't be used for outbound
	# TODO: this algorithm ignores time criteria of the dr_rule
	# which could lead to false positives if using this setting in drouting
	$avp(dr_ruleid) = $null;				# dr_ruleid matched
	$var(prefix_match_diff) = 1000;			# last match prefix diff
	$var(diff) = 1000;						# current entry prefix diff
	$var(prefix_match_priority) = 0;		# last match priority
	$var(priority) = 0;						# current entry priority
	$var(lookup) = $(rU{s.unescape.user});	# dnid to match against

	sht_iterator_start("iter", "prefix_to_route");
	while(sht_iterator_next("iter")) {
		# TODO: for now we use a literal prefix but we should change to supporting patterns
		# this would require updating drouting module to support pattern matching
		$var(regex) = $(shtitkey(iter){re.subst,/(\+|\*|\#)/\\\1/g}) + "([0-9])*";
		if ($var(lookup) =~ $var(regex)) {
			xlog("L_DBG", "prefix match on $shtitkey(iter)\n");
			# if priority is less than last match we don't update match
			$var(priority) = $(shtitval(iter){s.select,1,,}{s.int});
			if ($var(priority) >= $var(prefix_match_priority)) {
				# get the difference between prefix and match
				$var(diff) = $(var(lookup){s.len}) - $(shtitkey(iter){s.len});
				# bitwise absolute value: ( mask = n>>31; (mask^n) - mask )
				# we are assuming 32 bit integers
				$var(mask) = $var(diff) >> 31;
				$var(diff) = ($var(mask) ^ $var(diff)) - $var(mask);
				# if priority is greater than last match or priority is equal and
				# diff is less than last match (closer match) we update match
				if ($var(priority) > $var(prefix_match_priority) || $var(diff) < $var(prefix_match_diff)) {
					xlog("L_DBG", "prefix closer match priority=$var(priority) diff=$var(diff)\n");
					$avp(dr_ruleid) = $(shtitval(iter){s.select,0,,});
					$var(prefix_match_priority) = $var(priority);
					$var(prefix_match_diff) = $var(diff);
				}
			}
		}
	}
	sht_iterator_end("iter");

	if ($avp(dr_ruleid) != $null) {
		$avp(hardfwdinfo) = $sht(inbound_hardfwd=>$avp(dr_ruleid));
		$avp(failfwdinfo) = $sht(inbound_failfwd=>$avp(dr_ruleid));
	}

	return;
}

route[CHECK_DLG_ALLOWED] {
	# only INVITE/SUBSCRIBE/REFER are allowed to create dialogs
	# ref: RFC 3261 / RFC 3515
	if (!is_method("INVITE|SUBSCRIBE|REFER")) {
		return;
	}

	setflag(FLT_DLG_ALLOWED);
}

# Sets the following variables:
# $avp(auth_user)
# $avp(auth_pass)
# $avp(auth_realm)
# $dlg_var(src_auth_domain)
# $dlg_var(src_auth_user)
# $dlg_var(src_auth_pass)
# $dlg_var(src_auth_realm)
# $dlg_var(dst_auth_domain)
# $dlg_var(dst_auth_user)
# $dlg_var(dst_auth_pass)
# $dlg_var(dst_auth_realm)
route[SETUP_CALLAUTH_INFO] {
	$vn(saved_ru) = $ru;
	$vn(saved_du) = $du;
	if (uac_reg_request_to($dlg_var(src_gwgroupid), 0)) {
		$dlg_var(src_auth_domain) = $rd;
		$dlg_var(src_auth_user) = $avp(auth_user);
		$dlg_var(src_auth_pass) = $avp(auth_pass);
		$dlg_var(src_auth_realm) = $avp(auth_realm);
		$avp(auth_user) = $null;
		$avp(auth_pass) = $null;
		$avp(auth_realm) = $null;
	}
	if (uac_reg_request_to($dlg_var(dst_gwgroupid), 0)) {
		$dlg_var(dst_auth_domain) = $rd;
		$dlg_var(dst_auth_user) = $avp(auth_user);
		$dlg_var(dst_auth_pass) = $avp(auth_pass);
		$dlg_var(dst_auth_realm) = $avp(auth_realm);
	}
	$ru = $vn(saved_ru);
	$du = $vn(saved_du);
}

# Sets the following variables:
# $dlg_ctx(timeout)
# $dlg_ctx(timeout_route)
route[SETUP_DIALOG] {
	if (!isflagset(FLT_DLG_ALLOWED)) {
		return;
	}

#!ifdef WITH_CALL_SETTINGS
	# set the dialog timeout to the smallest timeout between the src and dst gwgroups
	if (!strempty($xavu(dst_call_settings=>timeout))) {
		$vn(call_timeout) = (int)$xavu(dst_call_settings=>timeout);
		if (!strempty($xavu(src_call_settings=>timeout)) && $vn(call_timeout) > $xavu(src_call_settings=>timeout)) {
			$vn(call_timeout) = (int)$xavu(src_call_settings=>timeout);
		}
	}
	else if (!strempty($xavu(src_call_settings=>timeout))) {
		$vn(call_timeout) = (int)$xavu(src_call_settings=>timeout);
	}
	if ($vn(call_timeout) != $null) {
		$dlg_ctx(timeout) = $vn(call_timeout);
		$dlg_ctx(timeout_route) = "DIALOG_TIMEOUT";
	}
#!endif
	# Create dialog if one doesn't already exists
 	if (!is_known_dlg()) {
		dlg_manage();
        }
}


# TODO: ipv6 support
route[SET_RECORD_ROUTE] {
	# remove any previous headers set
	remove_record_route();

	# TODO: someone give good explanation of the NLB record routing here
	if (("OUTBOUND_NLB_FQDN" != "") && ("INBOUND_NLB_FQDN" != "")) {
		record_route_preset("OUTBOUND_NLB_FQDN","INBOUND_NLB_FQDN");
		$dlg_var(sbc_translate) = "0";
	}
	else if (("OUTBOUND_NLB_FQDN" == "") && ("INBOUND_NLB_FQDN" != "")) {
		record_route_advertised_address("INBOUND_NLB_FQDN");
		$dlg_var(sbc_translate) = "0";
	}
#!ifdef WITH_MSTEAMS
	# TODO: needs check everytime this is called, can't store/check flag
	# MS Teams special use case - add hop from SIPS port to SIP port
	else if (isbflagset(FLB_DST_MSTEAMS)) {
		# TODO: if end-to-end encryption is used this may not work
		# TODO: we should be dynamically checking the transport for each side of the record route
		#		in this case we are missing TLS <-> TCP connections and TLS <-> TLS connections
		#		we should instead generalize the handling of different ports/protocols and whether r2=on should be added
		# TODO: not adding in check for IPv4 vs IPv6 vs Domain here since we are sending to ourself - is this assumption correct?
		record_route_preset("$dlg_var(dst_msteams_domain):SIPS_PORT;transport=tls;r2=on", "INTERNAL_IP_ADDR:SIP_PORT;transport=udp;r2=on");
		force_send_socket(tls:INTERNAL_IP_ADDR:SIPS_PORT);
		$dlg_var(sbc_translate) = "0";
	}
	# If coming from MSTEAMS, change Record Route to match the domain it's coming from
	else if (isbflagset(FLB_SRC_MSTEAMS)) {
		record_route_preset("$dlg_var(src_msteams_domain):SIP_PORT;transport=udp;r2=on", "$dlg_var(src_msteams_domain):SIPS_PORT;transport=tls;r2=on");
		$dlg_var(sbc_translate) = 1;
	}
#!endif
	# the source of the request will be following the Route / Record-Route headers
	# so we only need send them back to our internal ip if from within our subnet
	else if (isflagset(FLT_SRC_INTERNAL_IP)) {
		if (isflagset(FLT_DST_INTERNAL_IP)) {
			if (isflagset(FLT_SRC_IPV6)) {
				record_route_preset("[INTERNAL_IP6_ADDR]:$Rp");
			}
			else {
				record_route_preset("INTERNAL_IP_ADDR:$Rp");
			}
		}
		else {
			if (isflagset(FLT_SRC_IPV6)) {
				record_route_preset("[EXTERNAL_IP6_ADDR]:$Rp;r2=on", "[INTERNAL_IP6_ADDR]:$Rp;r2=on");
			}
			else {
				record_route_preset("EXTERNAL_IP_ADDR:$Rp;r2=on", "INTERNAL_IP_ADDR:$Rp;r2=on");
			}
		}
		$dlg_var(sbc_translate) = "0";
	}
	else if (isflagset(FLT_DST_INTERNAL_IP)) {
		if (isflagset(FLT_SRC_IPV6)) {
			record_route_preset("[INTERNAL_IP6_ADDR]:$Rp;r2=on", "[EXTERNAL_IP6_ADDR]:$Rp;r2=on");
		}
		else {
			record_route_preset("INTERNAL_IP_ADDR:$Rp;r2=on", "EXTERNAL_IP_ADDR:$Rp;r2=on");
		}
		$dlg_var(sbc_translate) = "0";
	}
	else {
		if (isflagset(FLT_SRC_IPV6)) {
			record_route_preset("[EXTERNAL_IP6_ADDR]:$Rp");
		}
		else {
			record_route_preset("EXTERNAL_IP_ADDR:$Rp");
		}
		$dlg_var(sbc_translate) = "0";
	}

	# store the source and destination for later usage within the dialog
	if ($du == $null) {
		$dlg_var(dst_uri) = $(ru{uri.duri});
	}
	else {
		$dlg_var(dst_uri) = $du;
	}
	$dlg_var(src_uri) = $sut;

	return;
}

# TODO: on configuration failure continue with next endpoint instead of routing to this endpoint
route[SET_DST_SIGNALLING] {
	switch ($dlg_var(dst_signalling)) {
		case "proxy":
			# TODO: in future releases "proxy" will mean record route through kamailio
			# 		and another option for bypassing kamailio will be available
			if ($du == $null) {
				$du = $(ru{uri.duri});
			}
			break;
		case "sip_udp":
			uri_param_rm("transport");
			if ($du == $null) {
				$du = "sip:" + $sel(ruri.hostport) + ";transport=udp";
			}
			else {
				$du = "sip:" + $sel(dst_uri.hostport) + ";transport=udp";
			}
			break;
		case "sip_tcp":
			uri_param_rm("transport");
			if ($du == $null) {
				$du = "sip:" + $sel(ruri.hostport) + ";transport=tcp";
			}
			else {
				$du = "sip:" + $sel(dst_uri.hostport) + ";transport=tcp";
			}
			break;
		case "sip_sctp":
			uri_param_rm("transport");
			if ($du == $null) {
				$du = "sip:" + $sel(ruri.hostport) + ";transport=sctp";
			}
			else {
				$du = "sip:" + $sel(dst_uri.hostport) + ";transport=sctp";
			}
			break;
		case "sip_ws":
			uri_param_rm("transport");
			if ($du == $null) {
				$du = "sip:" + $sel(ruri.hostport) + ";transport=ws";
			}
			else {
				$du = "sip:" + $sel(dst_uri.hostport) + ";transport=ws";
			}
			break;
		case "sips_tls":
			uri_param_rm("transport");
			if ($du == $null) {
				$du = "sips:" + $sel(ruri.hostport) + ";transport=tls";
			}
			else {
				$du = "sips:" + $sel(dst_uri.hostport) + ";transport=tls";
			}
			break;
		case "sips_sctp":
			uri_param_rm("transport");
			if ($du == $null) {
				$du = "sips:" + $sel(ruri.hostport) + ";transport=sctp";
			}
			else {
				$du = "sips:" + $sel(dst_uri.hostport) + ";transport=sctp";
			}
			break;
		case "sips_wss":
			uri_param_rm("transport");
			if ($du == $null) {
				$du = "sips:" + $sel(ruri.hostport) + ";transport=ws";
			}
			else {
				$du = "sips:" + $sel(dst_uri.hostport) + ";transport=ws";
			}
			break;
		default:
			xlog("L_WARN", "invalid signalling configuration requested for endpoint $dlg_var(dst_gwid)\n");
			break;
	}

	return;
}

# TODO: on configuration failure continue with next endpoint instead of routing to this endpoint
route[SET_DST_MEDIA] {

	if (!has_body("application/sdp"))  {
		return;
	}

	# TODO: revisit $dlg_var(FLD_USE_RTPE) usage here
	switch ($dlg_var(dst_media)) {
		case "proxy":
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(dst_media_tp) = "";
			# Setting a dialog variable since dlg_setflag doesn't see to work on Manage Branches
			$dlg_var(FLD_USE_RTPE) = "1";
			sdp_transport("$var(src_media_tp)");
			break;
		case "direct":
			dlg_resetflag(FLD_USE_RTPE);
			$dlg_var(FLD_USE_RTPE) = "0";
			$dlg_var(dst_media_tp) = "";
			$var(src_media_tp) = "";
			break;
		case "rtp_avp":
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(FLD_USE_RTPE) = "1";
			$dlg_var(dst_media_tp) = "RTP/AVP";
			sdp_transport("$var(src_media_tp)");
			break;
		case "rtp_savp":
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(FLD_USE_RTPE) = "1";
			$dlg_var(dst_media_tp) = "RTP/SAVP";
			sdp_transport("$var(src_media_tp)");
			break;
		case "rtp_avpf":
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(FLD_USE_RTPE) = "1";
			$dlg_var(dst_media_tp) = "RTP/AVPF";
			sdp_transport("$var(src_media_tp)");
			break;
		case "rtp_savpf":
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(FLD_USE_RTPE) = "1";
			$dlg_var(dst_media_tp) = "RTP/SAVPF";
			sdp_transport("$var(src_media_tp)");
			break;
		case "rtp_avp_any":
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(FLD_USE_RTPE) = "1";
			$dlg_var(dst_media_tp) = "UDP/TLS/RTP/SAVP";
			sdp_transport("$var(src_media_tp)");
			break;
		case "rtp_avpf_any":
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(FLD_USE_RTPE) = "1";
			$dlg_var(dst_media_tp) = "UDP/TLS/RTP/SAVPF";
			sdp_transport("$var(src_media_tp)");
			break;
		case "udptl":
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(FLD_USE_RTPE) = "1";
			$dlg_var(dst_media_tp) = "T.38=force";
			sdp_transport("$var(src_media_tp)");
			break;
		case "osrtp_avp":
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(FLD_USE_RTPE) = "1";
			$dlg_var(dst_media_tp) = "transport-protocol=RTP/AVP OSRTP=offer";
			sdp_transport("$var(src_media_tp)");
			break;
		case "osrtp_avpf":
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(FLD_USE_RTPE) = "1";
			$dlg_var(dst_media_tp) = "transport-protocol=RTP/AVPF OSRTP=offer";
			sdp_transport("$var(src_media_tp)");
			break;
		default:
			xlog("L_WARN", "invalid media configuration requested for endpoint $dlg_var(dst_gwid). Defaulting to RTPEngine enabled.\n");
			dlg_setflag(FLD_USE_RTPE);
			$dlg_var(dst_media_tp) = "";
			$var(src_media_tp) = "";
			break;
	}

	$dlg_var(src_media_tp) = $var(src_media_tp);

	return;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
	if (nat_uac_test("19")) {
		setbflag(FLB_NATB);
	}
#!endif

	return;
}

# Server / DMZ NAT detection
# Determine NAT requirements for destination and source and set flags for later usage
# TODO: source self is known after REQINIT, consider copying over transaction flags such as FLT_SRC_SELF (multiple transactions in flow)
route[SERVERNATDETECT] {
	# default to NULL
	$vn(dst_ipv4) = $null;
	$vn(dst_ipv6) = $null;

	# always reset flags when called
	resetflag(FLT_SRC_INTERNAL_IP);
	resetflag(FLT_DST_INTERNAL_IP);
	resetflag(FLT_SRC_IPV4);
	resetflag(FLT_DST_IPV4);
	resetflag(FLT_SRC_IPV6);
	resetflag(FLT_DST_IPV6);

	if ($dd == $null) {
		$var(dst) = $rd;
	}
	else {
		$var(dst) = $dd;
	}
	if (is_ipv4($var(dst))) {
		$vn(dst_ipv4) = $var(dst);
	}
	else if (is_ipv6($var(dst))) {
		$vn(dst_ipv6) = $var(dst);
	}
	else {
		if (dns_query($var(dst), "dst")) {
			$var(i) = 0;
			while ($var(i) < $dns(dst=>count)) {
				if ($vn(dst_ipv4) == $null && $dns(dst=>type[$var(i)]) == 4) {
					$vn(dst_ipv4) = $dns(dst=>addr[$var(i)]);
				}
				else if ($vn(dst_ipv6) == $null && $dns(dst=>type[$var(i)]) == 6) {
					$vn(dst_ipv6) = $dns(dst=>addr[$var(i)]);
				}
				$var(i) = $var(i) + 1;
			}
		}
		else {
			xlog("L_ERR", "dns query failed for $var(dst)\n");
		}
	}

#!ifdef WITH_SIGNAL_SERVERNAT
	# source does not change throughout
	if (is_in_subnet($si, "INTERNAL_IP_NET") || is_myself("$si")) {
		setflag(FLT_SRC_INTERNAL_IP);
		setflag(FLT_SRC_IPV4);
	}
	if (is_in_subnet($vn(dst_ipv4), "INTERNAL_IP_NET") || is_myself("$var(dst)")) {
		setflag(FLT_DST_INTERNAL_IP);
		setflag(FLT_DST_IPV4);
	}
#!endif

#!ifdef WITH_SIGNAL_SERVERNAT6
	# source does not change throughout
	if (!isflagset(FLT_SRC_INTERNAL_IP) && is_in_subnet($si, "INTERNAL_IP6_NET")) {
		setflag(FLT_SRC_INTERNAL_IP);
		setflag(FLT_SRC_IPV6);
	}
	if (!isflagset(FLT_DST_INTERNAL_IP) && is_in_subnet($vn(dst_ipv6), "INTERNAL_IP6_NET")) {
		setflag(FLT_DST_INTERNAL_IP);
		setflag(FLT_DST_IPV6);
	}
#!endif

#!ifdef WITH_DMZ
	# source does not change throughout
	if (!isflagset(FLT_SRC_INTERNAL_IP)) {
		if (is_in_subnet($si, "INTERNAL_IP_NET")) {
			setflag(FLT_SRC_INTERNAL_IP);
			setflag(FLT_SRC_IPV4);
		}
#!ifdef WITH_IPV6
		else if (is_in_subnet($si, "INTERNAL_IP6_NET")) {
			setflag(FLT_SRC_INTERNAL_IP);
			setflag(FLT_SRC_IPV6);
		}
#!endif
	}
	if (!isflagset(FLT_DST_INTERNAL_IP)) {
		if (is_in_subnet($vn(dst_ipv4), "INTERNAL_IP_NET")) {
			setflag(FLT_DST_INTERNAL_IP);
			setflag(FLT_DST_IPV4);
		}
#!ifdef WITH_IPV6
		else if (is_in_subnet($vn(dst_ipv4), "INTERNAL_IP6_NET")) {
			setflag(FLT_DST_INTERNAL_IP);
			setflag(FLT_DST_IPV6);
		}
#!endif
	}
#!endif

	return;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request() && isflagset(FLT_HAS_TOTAG) && check_route_param("nat=yes")) {
		setbflag(FLB_NATB);
	}

	if (!isbflagset(FLB_NATB)) {
		return;
	}

	# handle clientside NAT traversal (requests)
	if (is_request()) {
		# initial requests we can change some headers for the rest of the transaction
		if (!isflagset(FLT_HAS_TOTAG)) {
			# Contact and Via updates
			if (isflagset(FLT_SRC_SIP) && !isbflagset(FLB_SRC_MSTEAMS)) {
				fix_nated_contact();
				msg_apply_changes();
				force_rport();
			}
			# registration Contact update
			if (is_method("REGISTER")) {
				fix_nated_register();
			}
			# Route updates
			if (t_is_branch_route()) {
				add_rr_param(";nat=yes");
			}
		}
		# for dialog NAT traversal
		# only forward requests if there is an existing connection to the destination
		else {
			set_forward_no_connect();
		}
	}
	# handle clientside NAT traversal (replies)
	else {
		# only set contact alias on replies if B-Leg of call is NATed as well
		if (is_first_hop() && nat_uac_test("1")) {
			set_contact_alias();
		}
		# Do NAT traversal stuff for replies to a WebSocket connection
		# - even if it is not behind a NAT!
		# This won't be needed in the future if Kamailio and the
		# WebSocket client support Outbound and Path.
#!ifdef WITH_WEBSOCKETS
		if (isflagset(FLT_SRC_WS) && nat_uac_test("64")) {
			add_contact_alias();
		}
#!endif
	}

#!endif

	return;
}

# should only be called within request routes
route[RTPENGINEOFFER] {
#!ifdef WITH_RTPENGINE
	if (!dlg_isflagset(FLD_USE_RTPE)) {
		xlog("L_INFO", "RTPEngine is disabled\n");
		return;
	}
	xlog("L_INFO", "RTPEngine is enabled\n");

	# - Web to web
	if (isflagset(FLT_SRC_WS) && isbflagset(FLB_WS_DEVICE)) {
		$var(reflags) = "trust-address replace-origin replace-session-connection SDES-off ICE=force " + $dlg_var(dst_media_tp);
	}
	# - Web to SIP
	else if (isflagset(FLT_SRC_WS)) {
		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-demux ICE=remove " + $dlg_var(dst_media_tp);
	}
	# - SIP to web
	else if (isbflagset(FLB_WS_DEVICE)) {
		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-offer ICE=force transcode-PCMU transcode-G722 SDES-off " + $dlg_var(dst_media_tp);
	}
	# - MSTEAMS to SIP using RTP/AVP
	else if (isbflagset(FLB_SRC_MSTEAMS)) {
		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-offer port-latching ICE=remove " + $dlg_var(dst_media_tp);
#		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-offer ICE=remove RTP/AVP original-sendrecv";
	}
	# - MSTEAMS to SIP ONHOLD using RTP/AVP
	else if (isbflagset(FLB_SRC_MSTEAMS_ONHOLD)) {
		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-accept ICE=remove " + $dlg_var(dst_media_tp);
#		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-accept ICE=remove RTP/AVP original-sendrecv";
	}
	# - SIP to MSTEAMS
	else if (isbflagset(FLB_DST_MSTEAMS)) {
 		if (has_totag()) {

                        $var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-accept ICE=force transcode-PCMU transcode-G722 " + $dlg_var(dst_media_tp);
                }
                else {

                        $var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-offer ICE=force transcode-PCMU transcode-G722 " + $dlg_var(dst_media_tp);
                }

	}
	# - SIP to SIP
	else {
		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-demux ICE=remove " + $dlg_var(dst_media_tp);
	}

#!ifdef WITH_MEDIA_SERVERNAT
	# for serverside NAT we may need to use one of the internal IPs as the media address
	if (isflagset(FLT_DST_INTERNAL_IP)) {
		if (isflagset(FLT_DST_IPV6)) {
			$var(reflags) = $var(reflags) + " media-address=INTERNAL_IP6_ADDR";
		}
		else {
			$var(reflags)= $var(reflags) + " media-address=INTERNAL_IP_ADDR";
		}
	}
	else {
		if (isflagset(FLT_DST_IPV6)) {
			$var(reflags) = $var(reflags) + " media-address=EXTERNAL_IP6_ADDR";
		}
		else {
			$var(reflags)= $var(reflags) + " media-address=EXTERNAL_IP_ADDR";
		}
	}

#!ifdef WITH_DMZ
	if (isflagset(FLT_SRC_INTERNAL_IP) && !isflagset(FLT_DST_INTERNAL_IP))  {
		$var(reflags)= $var(reflags) + " direction=private direction=public";
	}
	else if (!isflagset(FLT_SRC_INTERNAL_IP) && isflagset(FLT_DST_INTERNAL_IP)) {
		$var(reflags)= $var(reflags) + " direction=public direction=private";
	}
#!else
#!ifdef WITH_IPV6
	# select interface within rtpengine based on IP versions (by default will use the IPv4 interface)
	# only needed when not using the default interface (1st listen interface for rtpengine)
    if (isflagset(FLT_SRC_IPV4) && isflagset(FLT_DST_IPV6)) {
		$var(reflags)= $var(reflags) + " direction=ipv4 direction=ipv6";
	}
	else if (isflagset(FLT_SRC_IPV6) && isflagset(FLT_DST_IPV4)) {
		$var(reflags)= $var(reflags) + " direction=ipv6 direction=ipv4";
	}
	else if (isflagset(FLT_SRC_IPV6) && isflagset(FLT_DST_IPV6)) {
		$var(reflags)= $var(reflags) + " direction=ipv6 direction=ipv6";
	}
	else {
		$var(reflags)= $var(reflags) + " direction=ipv4 direction=ipv4";
	}
#!endif
#!endif
#!endif

	xlog("L_INFO", "reflags: $var(reflags)\n");
	if (!rtpengine_offer("$var(reflags)")) {
		send_reply("503", "Service not available");
		exit;
	}
#!endif

	return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif

	if (check_route_param("rwdst")) {
		if (is_direction("downstream")) {
			$du = $dlg_var(dst_uri);
		}
		else {
			$du = $dlg_var(src_uri);
		}
	}
}


route[RTPENGINEANSWER] {
#!ifdef WITH_RTPENGINE
	if ($dlg_var(FLD_USE_RTPE) == "0") {
		xlog("L_INFO", "RTPEngine is disabled\n");
		return;
	}
	xlog("L_INFO", "RTPEngine is enabled\n");

	# - Web to web
	if (isflagset(FLT_SRC_WS) && isbflagset(FLB_WS_DEVICE)) {
		$var(reflags) = "trust-address replace-origin replace-session-connection SDES-off ICE=force " + $dlg_var(src_media_tp);
	}
	# - Web to SIP
	else if (isflagset(FLT_SRC_WS)) {
		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-require ICE=force " + $dlg_var(src_media_tp);
	}
	# - MSTEAMS to SIP using RTP/AVP
	else if (isbflagset(FLB_DST_MSTEAMS)) {
		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-offer ICE=remove " + $dlg_var(src_media_tp);
	}
	# - SIP to MSTEAMS
	else if (isbflagset(FLB_SRC_MSTEAMS)) {
		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-require ICE=force transcode-PCMU transcode-G722 SDES-off " + $dlg_var(src_media_tp);
#		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-require ICE=force codec-transcode=PCMU codec-transcode=PCMA codec-transcode=G722 codec-transcode=G729 SDES-off RTP/SAVP original-sendrecv";
	}
	# - SIP to MSTEAMS ONHOLD
	else if (isbflagset(FLB_SRC_MSTEAMS_ONHOLD)) {
		xlog("L_DBG", "ONHOLD - ANSWER\n");
		$var(reflags) = "trust-address replace-origin replace-session-connection ICE=remove transcode-PCMU transcode-G722 SDES-off " + $dlg_var(src_media_tp);
#		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-require ICE=force codec-transcode=PCMU codec-transcode=PCMA codec-transcode=G722 codec-transcode=G729 SDES-off RTP/SAVP original-sendrecv";
	}
	# - SIP to SIP
	else {
		$var(reflags) = "trust-address replace-origin replace-session-connection rtcp-mux-demux ICE=remove " + $dlg_var(src_media_tp);
	}

#!ifdef WITH_MEDIA_SERVERNAT
	# NOTE: no need to set direction= here, direction will be determined from the offer
	# for serverside NAT we may need to use one of the internal IPs as the media address
	if (isflagset(FLT_SRC_INTERNAL_IP)) {
		if (isflagset(FLT_SRC_IPV6)) {
			$var(reflags)= $var(reflags) + " media-address=INTERNAL_IP6_ADDR";
		}
		else {
			$var(reflags)= $var(reflags) + " media-address=INTERNAL_IP_ADDR";
		}
	}
	else {
		if (isflagset(FLT_SRC_IPV6)) {
			$var(reflags)= $var(reflags) + " media-address=EXTERNAL_IP6_ADDR";
		}
		else {
			$var(reflags)= $var(reflags) + " media-address=EXTERNAL_IP_ADDR";
		}
	}
#!endif

	xlog("L_INFO", "reflags: $var(reflags)\n");
	if (!rtpengine_answer("$var(reflags)")) {
		send_reply("503", "Service not available");
		route(RTPENGINEDELETE);
		exit;
	}
#!endif

	return;
}

route[RTPENGINEDELETE] {
#!ifdef WITH_RTPENGINE
	if (!dlg_isflagset(FLD_USE_RTPE)) {
		xlog("L_INFO", "RTPEngine is disabled\n");
		return;
	}
	xlog("L_INFO", "RTPEngine is enabled\n");

	rtpengine_delete();
#!endif

	return;
}

# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] {
	# allow XMLRPC from localhost
	if ((method=="POST" || method=="GET") && (src_ip==127.0.0.1)) {
		# close connection only for xmlrpclib user agents (there is a bug in
		# xmlrpclib: it waits for EOF before interpreting the response).
		if ($hdr(User-Agent) =~ "xmlrpclib")
			set_reply_close();
		set_reply_no_connect();
		dispatch_rpc();
		exit;
	}

	send_reply("403", "Forbidden");
	exit;
}
#!endif

# Routing to voicemail server
route[TOVOICEMAIL] {
#!ifdef WITH_VOICEMAIL
	if (!is_method("INVITE|SUBSCRIBE")) {
		return;
	}

	# check if VoiceMail server IP is defined
	if (strempty($sel(cfg_get.voicemail.srv_ip))) {
		xlog("L_ERR", "VoiceMail routing enabled but IP not defined\n");
		return;
	}

	if (is_method("INVITE")) {
		if ($avp(oexten) == $null) {
			return;
		}
		$ru = "sip:" + $avp(oexten) + "@" + $sel(cfg_get.voicemail.srv_ip) + ":" + $sel(cfg_get.voicemail.srv_port);
	}
	else {
		if ($rU == $null) {
			return;
		}
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.voicemail.srv_ip) + ":" + $sel(cfg_get.voicemail.srv_port);
	}

	route(RELAY);
	exit;
#!endif

	return;
}

# Populate CDRs Table
#!ifdef WITH_CDRS
route[CDRS] {
	sql_query("kam","call kamailio_cdrs()","rb");
	# we are not using billing features
	#sql_query("kam","call kamailio_rating('default')","rb");
}
#!endif

# send async http request for notifications
# required:     $avp(notification_type)
# required:     $avp(notification_gwgroupid)
# optional:     $avp(notification_gwid)
route[SEND_NOTIFICATION] {
	if ($avp(notification_type) != $null && $avp(notification_gwgroupid) != $null) {
		$http_req(method) = "POST";
		$http_req(hdr) = "User-Agent: http_async_client";
		$http_req(hdr) = "Authorization: Bearer " + $sel(cfg_get.server.api_token);
		$http_req(body) = '{"gwgroupid":' + $avp(notification_gwgroupid) + ', "type":' + $avp(notification_type) +
				', "gwid":' + $avp(notification_gwid) + ', "text_body":"Gateway Group [' + $avp(notification_gwgroupid) +
				'] triggered the following notification for Gateway [' + $avp(notification_gwid) + ']"}';
		$http_req(suspend) = 0;

		xlog("L_INFO", "Sending request to $sel(cfg_get.server.api_server)/api/v1/notification/gwgroup for type $avp(notification_type)\n");
		http_async_query("$sel(cfg_get.server.api_server)/api/v1/notification/gwgroup", "HTTP_REPLY");
	}
	else {
		xlog("L_ERR", "avp 'notification_type' and 'notification_gwgroupid' are required for notification sending\n");
	}

	$avp(notification_type) = $null;
	$avp(notification_gwgroupid) = $null;
	$avp(notification_gwid) = $null;
}

route[HTTP_REPLY] {
	if ($http_ok) {
		xlog("L_INFO", "status: $http_rs\n");
		xlog("L_DBG", "body: $http_rb\n");
	}
	else {
		xlog("L_ERR", "error: $http_err)\n");
	}
}

route[DIALOG_TIMEOUT] {
	# TODO: handle edge cases
	# 		when we rewrite the reply this may cause issues
	# 		dialog module is using tm underneath to send these requests
  	#		it seems to be using the contact from either side to teardown the call
	#if ($dlg_var(sbc_translate) == "1") {
	#
	#}
	#else {
	#	dlg_bye("all");
	#}
	dlg_bye("all");

	# we still need to cleanup rtpengine sessions
	route(RTPENGINEDELETE);
}

# executed when 200 OK reply for INVITE is processed
event_route[dialog:start] {
#!ifdef WITH_CALL_SETTINGS
	# increment the concurrent calls htable
	if ($dlg_var(src_gwgroupid) != $dlg_var(dst_gwgroupid)) {
		sht_lock("concurrent_calls=>$dlg_var(src_gwgroupid)");
		$sht(concurrent_calls=>$dlg_var(src_gwgroupid)) = $sht(concurrent_calls=>$dlg_var(src_gwgroupid)) + 1;
		sht_unlock("concurrent_calls=>$dlg_var(src_gwgroupid)");
	}
	sht_lock("concurrent_calls=>$dlg_var(dst_gwgroupid)");
	$sht(concurrent_calls=>$dlg_var(dst_gwgroupid)) = $sht(concurrent_calls=>$dlg_var(dst_gwgroupid)) + 1;
	sht_unlock("concurrent_calls=>$dlg_var(dst_gwgroupid)");
#!endif

	return;
}

# executed when dialog is not completed (300 or greater reply code to INVITE)
#event_route[dialog:failed] {
#	return;
#}

# executed when BYE is processed or dialog timed out
event_route[dialog:end] {
#!ifdef WITH_CALL_SETTINGS
	# decrement the concurrent calls htable
	if ($dlg_var(src_gwgroupid) != $dlg_var(dst_gwgroupid)) {
		sht_lock("concurrent_calls=>$dlg_var(src_gwgroupid)");
		$sht(concurrent_calls=>$dlg_var(src_gwgroupid)) = $sht(concurrent_calls=>$dlg_var(src_gwgroupid)) - 1;
		sht_unlock("concurrent_calls=>$dlg_var(src_gwgroupid)");
	}
	sht_lock("concurrent_calls=>$dlg_var(dst_gwgroupid)");
	$sht(concurrent_calls=>$dlg_var(dst_gwgroupid)) = $sht(concurrent_calls=>$dlg_var(dst_gwgroupid)) - 1;
	sht_unlock("concurrent_calls=>$dlg_var(dst_gwgroupid)");
#!endif

	return;
}

event_route[uac:reply] {
	xlog("L_DBG", "Request sent to $uac_req(ruri) with event code $uac_req(evcode)\n");
}

event_route[xhttp:request] {
	if ($hu =~ "^/api/kamailio" && dst_ip==127.0.0.1) {
		jsonrpc_dispatch();
	}
#!ifdef WITH_WEBSOCKETS
	else if ($Rp == "WSS_PORT") {
		if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade" && $rm =~ "GET") {
			if (ws_handle_handshake()) {
				# Optional... cache some information about the
				# successful connection
				exit;
			}
		}
	}
	else {
		xhttp_reply("403", "Forbidden", "text/html",
			"<html><body>Will only communicate on the local interface or WebSocket Port WSS_PORT</body></html>");
		exit;
	}
#!endif

	return;
}

# executed for tm locally created requests
event_route[tm:local-request] {
#!ifdef WITH_MSTEAMS
	if (is_method("OPTIONS") && $ru =~ "pstnhub.microsoft.com") {
		append_hf("Contact: <sip:$fd:SIPS_PORT;transport=tls>\r\n");
		xlog("L_DBG", "Changed contact to $ct\n");
	}
#!endif

	# TODO: why are we changing the contact here?
	# Get destination IP
	$var(destIP)=$(du{s.select,1,:});

	# Only change the contact if an Inound NLB is set and the Register is going to a carrier
	if (is_method("REGISTER") && ("INBOUND_NLB_FQDN" != "") && !allow_address(FLT_PBX, "$var(destIP)", 0)) {
		if (subst('/^Contact: <sip:([0-9]+)@(.*)$/Contact: <sip:\1@INBOUND_NLB_FQDN>/ig')) {
			xlog("L_DBG", "Changed REGISTER contact to load balancer address: $mb\n");
		}
	}
}

# executed for tm locally created responses
#event_route[tm:local-response] {
#
#}

# executed for sl received (and ignored) ACK responses
#event_route[sl:filtered-ack] {
#
#}

# executed for sl locally created responses
#event_route[sl:local-response] {
#
#}

event_route[usrloc:contact-expired] {
	if (sql_xquery("kam", "SELECT rpid AS gwgroupid FROM subscriber WHERE username='$(ulc(exp=>addr){uri.user})'", "rows") == 1) {
		$var(src_gwgroupid) = $xavp(rows=>gwgroupid);
		$var(received_addr) = $(ulc(exp=>received){re.subst,/^(sip:|sips:)?(.*)$/\2/});

		if (sql_xquery("kam", "SELECT gwid FROM dr_gateways WHERE address='$var(received_addr)' AND description REGEXP 'gwgroup:$var(src_gwgroupid)(,|$$)'", "rows") == 1) {
			$var(src_gwid) = $xavp(rows=>gwid);

			xlog("L_DBG", "found gateway $var(src_gwid) for address $var(received_addr), removing from gwgroup $var(src_gwgroupid)\n");
			sql_query("kam", "DELETE FROM dr_gateways WHERE gwid='$var(src_gwid)'");
			sql_query("kam", "UPDATE dr_gw_lists SET gwlist=REGEXP_REPLACE(REGEXP_REPLACE(gwlist, '([,;])?$var(src_gwid)', ''), '^([,;])', '') WHERE id=$var(src_gwgroupid)");

			jsonrpc_exec('{"jsonrpc": "2.0", "method": "drouting.reload", "id": 1}');
		}
	}
}

route[REMOVE_REFER] {
	if (subst_hf("Allow", "/(.+)(REFER,)\s?(.+)/\1\3/", "f")) {
		xlog("L_INFO", "Removing REFER from Accepted Method to $du\n");
		if (!msg_apply_changes()) {
			xlog("L_ERR", "failed applying changes to message\n");
		}
	}
}

# CUSTOM: stateful SBC translations
route[SBC_TRANSLATE_LR] {
#!ifdef WITH_NAT
	if (!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif

	xlog("L_DBG", "request values before SBC translations: ru=$ru, du=$du dlg_var(src_cturi)=$dlg_var(src_cturi) dlg_var(dst_duri)=$dlg_var(dst_duri) dlg_var(dst_cturi)=$dlg_var(dst_cturi)\n");
	if (is_direction("downstream")) {
		$ru = $dlg_var(src_cturi);
		$du = $dlg_var(dst_duri);
		subst_hf("Contact", "/.*/<$dlg_var(dst_cturi)>/", "f");
		if (!strempty($dlg_var(dst_auth_user))) {
			$avp(auth_user) = $dlg_var(dst_auth_user);
			$avp(auth_pass) = $dlg_var(dst_auth_pass);
			$avp(auth_realm) = $dlg_var(dst_auth_realm);
		}
	}
	else if (is_direction("upstream")) {
		$ru = $dlg_var(dst_cturi);
		$du = $dlg_var(src_duri);
		subst_hf("Contact", "/.*/<$dlg_var(src_cturi)>/", "f");
		if (!strempty($dlg_var(src_auth_user))) {
			$avp(auth_user) = $dlg_var(src_auth_user);
			$avp(auth_pass) = $dlg_var(src_auth_pass);
			$avp(auth_realm) = $dlg_var(src_auth_realm);
		}
	}
	else {
		xlog("L_WARN", "could not determine call direction\n");
	}
	xlog("L_DBG", "request values after SBC translations: ru=$ru, du=$du\n");
}



route[SBC_TRANSLATE_SR] {
#!ifdef WITH_NAT
	if (!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif

	xlog("L_DBG", "request values before SBC translations: ru=$ru, du=$du dlg_var(src_cturi)=$dlg_var(src_cturi) dlg_var(dst_duri)=$dlg_var(dst_duri) dlg_var(dst_cturi)=$dlg_var(dst_cturi)\n");
	if ($ft == $dlg(from_tag)) {
		$ru = $dlg_var(src_cturi);
		$du = $dlg_var(dst_duri);
		subst_hf("Contact", "/.*/<$dlg_var(dst_cturi)>/", "f");
		if (!strempty($dlg_var(dst_auth_user))) {
			$avp(auth_user) = $dlg_var(dst_auth_user);
			$avp(auth_pass) = $dlg_var(dst_auth_pass);
			$avp(auth_realm) = $dlg_var(dst_auth_realm);
		}
	}
	else if ($ft == $dlg(to_tag)) {
		$ru = $dlg_var(dst_cturi);
		$du = $dlg_var(src_duri);
		subst_hf("Contact", "/.*/<$dlg_var(src_cturi)>/", "f");
		if (!strempty($dlg_var(src_auth_user))) {
			$avp(auth_user) = $dlg_var(src_auth_user);
			$avp(auth_pass) = $dlg_var(src_auth_pass);
			$avp(auth_realm) = $dlg_var(src_auth_realm);
		}
	}
	else {
		xlog("L_WARN", "could not determine call direction\n");
	}
	xlog("L_DBG", "request values after SBC translations: ru=$ru, du=$du\n");
}

# Rewrite the Contact domain with given one
# required:     $var(ct_domain)

# optional:     $var(transport)

route[REPLACE_CONTACT_DOMAIN] {
	if (!strempty($sel(contact.uri.type))) {
		$var(ct_uri) = $sel(contact.uri.type) + ":";
	}
	else {
		$var(ct_uri) = "sip:";
	}
	if (!strempty($sel(contact.uri.user))) {
		$var(ct_uri) = $var(ct_uri) + $sel(contact.uri.user) + "@" + $var(ct_domain);
	}
	else  {
		$var(ct_uri) = $var(ct_uri) + "@" + $var(ct_domain);
	}
	if (!strempty($sel(contact.uri.port))) {
		$var(ct_uri) = $var(ct_uri) + ":" + $sel(contact.uri.port);
	}
	
  if (!strempty($var(transport))) {

                $var(ct_uri) = $var(ct_uri) + ";" + $var(transport);
  }
  
  if (!strempty($sel(contact.uri.params))) {

                $var(ct_uri) = $var(ct_uri) + ";" + $sel(contact.uri.params);
 
		if (isbflagset(FLB_WS_DEVICE)) {
			$var(ct_uri) = $var(ct_uri) + ";" + "domain=" + $var(ct_domain) + ";" + "exten=" + $fU;
		 }
  }
  else {
		if (isbflagset(FLB_WS_DEVICE)) {
			$var(ct_uri) = $var(ct_uri) + ";" + "domain=" + $var(ct_domain) + ";" + "exten=" + $fU;
		 }
  }
  

	if (subst_hf("Contact", "/<([^>]+)>(.*)/<$var(ct_uri)>\2/", "f")) {
		xlog("L_INFO", "changed contact to match From domain\n");
		if (!msg_apply_changes()) {
			xlog("L_ERR", "failed applying changes to message\n");
		}
	}


	
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xlog("L_DBG", "new branch [$T_branch_idx] created to $ru via $du\n");

	if (isbflagset(FLB_WS_DEVICE)) {
		$var(FLB_WS_DEVICE) = 1;
	}
	else {
		$var(FLB_WS_DEVICE) = 0;
	}

	if (has_body("application/sdp") || isbflagset(FLB_SRC_MSTEAMS)) {
		route(RTPENGINEOFFER);
		# if you do not want the extra RTPEngine param then uncomment this line
		#sdp_remove_line_by_prefix("a=rtpengine");
	}
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
	xlog("L_DBG", "incoming reply from source address $si:$sp\n");

	# handle non-error replies
	if (t_check_status("[12][0-9][0-9]")) {
		if ($dlg_var(sbc_translate) == "1") {
			# let UAC think we are communicating with original request values
			# we will handle translations on our end
			$fu = $dlg_var(src_ofuri);
			$tu = $dlg_var(src_oturi);
			subst_hf("Contact", "/.*/<$dlg_var(src_oruri)>/", "f");
		}

		# handle clientside NAT
		route(NATMANAGE);

		# handle SDP munging with rtpengine
		if (has_body("application/sdp")) {
			route(RTPENGINEANSWER);
			if ($avp(sdp_media_direction) != $null) {
				if (!msg_apply_changes()) {
					xlog("L_ERR", "could not update sdp");
				}
				if (!subst("/^a=(sendrecv|recvonly|sendonly|inactive).*/a=$avp(sdp_media_direction)/")) {
					#search_append_body("^a=.+", "a=$avp(sdp_media_direction)");
					xlog("L_ERR", "could not update sdp\n");
				}
				if (!msg_apply_changes()) {
					xlog("L_ERR", "could not update sdp\n");
				}
			}
		}
	}
	# TODO: why are we dropping 183 replies to MSTEAMS? - marked for review/validation
	if (t_check_status("183") && isbflagset(FLB_DST_MSTEAMS)) {
		drop();
	}
	
	if (t_check_status("200") && !strempty($dlg_var(src_msteams_domain))) {	
		if (is_present_hf("ALLOW")) {

			#Prevent MSTeams from sending REFER requests
                        if ((int)$sel(cfg_get.server.msteams_disable_refer)) {
		route(REMOVE_REFER);
                        }
                }
                else {
                        append_hf("ALLOW: INVITE,ACK,OPTIONS,CANCEL,BYE,NOTIFY\r\n");
               }
		xlog("L_INFO", "+++ Remove REFER\n");
	}

		# set the final ru for subsequent requests to the contact from the 200
		if (t_check_status("200")) {
			if ($ct =~ "<.*>") {
				$dlg_var(src_cturi) = $(ct{s.select,0,>}{s.select,1,<});
			}
			else {
				$dlg_var(src_cturi) = $ct;
			}
		}

#	if (t_check_status("100|180|181|183") && $avp(calltype) == "inbound") {
#		# Increase the lifetime of the current INVITE to pbx_invite_timeout_aftertry if endpoint returns 100/180/181/183.
#		# This means that the endpoint is at least trying to establish the call. So, we will extend the timeout.
#
#		$var(pbx_invite_timeout) = (int)$sel(cfg_get.server.pbx_invite_timeout_aftertry);
#		t_set_max_lifetime($var(pbx_invite_timeout), 0);
#		xlog("L_DBG", "Increasing the Invite Timeout for <$ci> to <$var(pbx_invite_timeout)>\n");
#	}
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	# Capture the Failure in the CDR
	setflag(FLT_ACCFAILED);

	route(NATMANAGE);

	if (t_is_canceled()) {
		route(RTPENGINEDELETE);
		exit;
	}

#!ifdef WITH_BLOCK3XX
	# block call redirect based on 3xx replies.
	if (t_check_status("3[0-9][0-9]")) {
		t_reply("403", "Redirect Forbidden");
		route(RTPENGINEDELETE);
		exit;
	}
#!endif

	# use uac credentials if set by in SET_CALLAUTH_INFO
	if (t_check_status("401|407") && !strempty($avp(auth_user))) {
		t_drop_replies();

#!ifdef WITH_UAC
		if (!(uac_auth() && t_relay())) {
			xlog("L_INFO", "UAC Authentication failed\n");
			t_reply("503","Service not available");
			route(RTPENGINEDELETE);
		}
		exit;
#!else
		xlog("L_WARN", "destination requested UAC auth when it is not enabled\n");
		t_reply("503", "Service not available");
		route(RTPENGINEDELETE);
		exit;
#!endif
	}

	# if using pass thru auth relay the reply
	if (t_check_status("401|407") && isflagset(FLT_PASSTHRU_AUTH)) {
		t_relay();
		exit;
	}

#!ifdef WITH_MSTEAMS
 	if (t_check_status("4[0-9][0-9]") && isbflagset(FLB_DST_MSTEAMS)) {
 		t_relay();
 		exit;
 	}
#!endif

#!ifdef WITH_DROUTE
	if (t_check_status("[0-6][0-9][0-9]") || !t_any_replied()) {
		if (use_next_gw()) {
			# set du to match what drouting selected
			$du = $(ru{uri.duri});

			# Set INVITE  max lifetime to ensure Primary and Secondary PBX server feature works.
			if (isbflagset(FLB_SRC_CARRIER)) {
				t_set_fr((int)$sel(cfg_get.server.pbx_invite_timeout_aftertry), (int)$sel(cfg_get.server.pbx_invite_timeout));
			}
				
			$du = $ru;
			route(RELAY);
			exit;
		}
		else {
			# Only intervene on a request from the Carrier
			if (isbflagset(FLB_SRC_CARRIER)) {
				# this route will check for failover and return false if it does not route the call
				# if we are not failover routing, then none of the routes were successful and we send back an error
				if (!route(NEXTHOP_FAILOVER)) {
					t_reply("503","Service not available");

					# we can only send notification if mapped to endpoint group
					if ($dlg_var(src_gwtype) == FLT_PBX) {
						$avp(notification_type) = NOTIFICATION_GWFAILURE;
						$avp(notification_gwgroupid) = $dlg_var(src_gwgroupid);
						$avp(notification_gwid) = $dlg_var(src_gwid);
						route(SEND_NOTIFICATION);
					}
					else if ($dlg_var(dst_gwtype) == FLT_PBX) {
						$avp(notification_type) = NOTIFICATION_GWFAILURE;
						$avp(notification_gwgroupid) = $dlg_var(dst_gwgroupid);
						$avp(notification_gwid) = $dlg_var(dst_gwid);
						route(SEND_NOTIFICATION);
					}
				}
			}
			# Don't teardown the RTPEngine if coming or going to MSTeams
			if (!isbflagset(FLB_SRC_MSTEAMS)) {
				xlog("L_DBG", "Shutting Down RTPEngine due to receiving reply code: $rs from $si");
				route(RTPENGINEDELETE);
			}
			exit;
		}
	}
#!endif

	if (t_branch_timeout()) {
		route(RTPENGINEDELETE);
		exit;
	}

#!ifdef WITH_VOICEMAIL
	# serial forking
	# - route to voicemail on busy or no answer (timeout)
	if (t_check_status("486|408")) {
		$du = $null;
		route(TOVOICEMAIL);
		route(RTPENGINEDELETE);
		exit;
	}
#!endif
}

# TODO: FLB_SRC_PBX is not set within in-dialog requests
route[PBX_TO_ENDPOINT_LOOKUP] {
	# Lookup the actual location of endpoint if
	# coming from a PBX and the request domain is a local ip address
	if (isbflagset(FLB_SRC_PBX) && is_ip_rfc1918($rd)) {
		if (lookup("location","sip:$rU@$fd")) {
			xlog("L_DBG", "Looking up the domain and getting domain: $fd\n");
		}
	}
}

# TODO: dynamically get user_tn / pilot_tn from user configs
# Carrier Enrichment for CenturyLink
# validated SIP carriers:
# voip.centurylink.com
# 65.149.22.7, 65.149.23.7, 65.149.24.7, 65.149.25.7
# 216.206.64.7, 216.206.64.71, 216.206.64.91
# 216.206.66.7, 216.206.66.71, 216.206.66.91
route[ENRICH_CARRIER_CENTURYLINK_OUTBOUND] {
	$var(domain) = "voip.centurylink.com";
	$var(user_tn) = "6467687570";
	$var(pilot_tn) = "6467687572";

	if ($rd =~ "$var(domain).*|65.149.22.7.*|65.149.23.7.*|65.149.24.7.*|65.149.25.7.*|216.206.64.7.*|216.206.64.71.*|216.206.64.91.*|216.206.66.7.*|216.206.66.71.*|216.206.66.91.*") {
		xlog("L_INFO", "centurylink carrier match\n");
		$du = $ru;
		$rd = $var(domain);
		# Remove the port
		$rp = "";
		# Change the from and to domain to match the carrier domain name
		$td = $var(domain);
		$fd = $var(domain);
		# Uncomment this line if you need to change the from user to the user_tn
		#$fU = $var(user_tn);
		# Uncomment this line if you need to change the domain of the contact - this is not recommended
		#subst('/^Contact: <sip:([0-9]+)@(.*)$/Contact: <sip:\1@107.21.184.251>/ig')
		# Add P-Asserted-Identity per the carriers requirement
		append_hf("P-Asserted-Identity: <sip:$var(pilot_tn)@$var(domain)>\r\n");
		if (!msg_apply_changes()) {
			xlog("L_ERR", "failed applying changes\n");
		}
	}
}

route[ENRICH_CARRIER_SIGNALWIRE_INBOUND] {
	$var(domain_lookup) = ".+sip.signalwire.com";

	xlog("L_DBG", "before transform:\n$mb\n");

	if ($td =~ $var(domain_lookup)) {
		xlog("L_INFO", "signalwire carrier match\n");

		# Change the "request username" to "to username"
		$rU = $tU;
		if (!msg_apply_changes()) {
			xlog("L_ERR", "failed applying changes\n");
		}

		xlog("L_DBG", "after transform:\n$mb\n");
	}
}

route[ENRICH_CARRIER_SIGNALWIRE_OUTBOUND] {
	$var(domain) = "sip.signalwire.com";
	$var(domain_lookup) = ".+sip.signalwire.com";
	$var(user) = $fU;

	xlog("L_DBG", "before transform:\n$mb\n");

	if ($rd =~ $var(domain_lookup)) {
		xlog("L_INFO", "signalwire carrier match\n");

		# Change the from domain to the request domain
		$fd = $rd;
		# Change the from user to the authenticated user
		$fU = $avp(auth_user);

		# Add the callerid
		append_hf("P-Asserted-Identity: <sip:$var(user)@$var(domain)>\r\n");
		if (!msg_apply_changes()) {
			xlog("L_ERR", "failed applying changes\n");
		}

		xlog("L_DBG", "after transform:\n$mb\n");
	}
}

route[ENRICH_CARRIER_INBOUND] {
	route(ENRICH_CARRIER_SIGNALWIRE_INBOUND);
}

# Carrier Enrichment
route[ENRICH_CARRIER_OUTBOUND] {
	route(ENRICH_CARRIER_CENTURYLINK_OUTBOUND);
	route(ENRICH_CARRIER_SIGNALWIRE_OUTBOUND);
}

####### CUSTOM_ROUTING_START #########
# add custom routes here

####### CUSTOM_ROUTING_END #########

